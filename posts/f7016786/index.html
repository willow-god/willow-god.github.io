<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java课程主要内容回顾 | LiuShen's Blog</title><meta name="author" content="Willow-God"><meta name="copyright" content="Willow-God"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="考试分数占比卷A  单选题：30道，每题1分 判断题：10道，每题1分 程序阅读题：5道，每题6分 编程题：2道，每题15分  卷B  单选题：20道 判断题：10道 填空题：10道  成绩占比：  平时成绩：30% 前七章占比：85%  考试重点归纳总结第一章：JAVA语言基础背景知识（单选题，判断题，大题不难） Java的发展历史：Java是由Sun Microsystems的工程师James">
<meta property="og:type" content="article">
<meta property="og:title" content="Java课程主要内容回顾">
<meta property="og:url" content="https://blog.liushen.fun/posts/f7016786/index.html">
<meta property="og:site_name" content="LiuShen's Blog">
<meta property="og:description" content="考试分数占比卷A  单选题：30道，每题1分 判断题：10道，每题1分 程序阅读题：5道，每题6分 编程题：2道，每题15分  卷B  单选题：20道 判断题：10道 填空题：10道  成绩占比：  平时成绩：30% 前七章占比：85%  考试重点归纳总结第一章：JAVA语言基础背景知识（单选题，判断题，大题不难） Java的发展历史：Java是由Sun Microsystems的工程师James">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wallpapercave.com/wp/wp7250277.jpg">
<meta property="article:published_time" content="2023-11-30T16:00:00.000Z">
<meta property="article:modified_time" content="2023-12-20T16:00:00.000Z">
<meta property="article:author" content="Willow-God">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="期末复习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wallpapercave.com/wp/wp7250277.jpg"><link rel="shortcut icon" href="/info/avatar.ico"><link rel="canonical" href="https://blog.liushen.fun/posts/f7016786/index.html"><link rel="preconnect"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css?v=5.0.0"><link rel="stylesheet" href="/css/custom.css?v=5.0.0"><link rel="stylesheet" href="/pluginsSrc/@fortawesome/fontawesome-free/css/all.min.css?v=6.6.0"><link rel="stylesheet" href="/pluginsSrc/@fancyapps/ui/dist/fancybox/fancybox.css?v=5.0.36" media="print" onload="this.media='all'"><script>(()=>{
      const saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
      
      window.btf = {
        saveToLocal: saveToLocal,
        getScript: (url, attr = {}) => new Promise((resolve, reject) => {
          const script = document.createElement('script')
          script.src = url
          script.async = true
          script.onerror = reject
          script.onload = script.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            script.onload = script.onreadystatechange = null
            resolve()
          }

          Object.keys(attr).forEach(key => {
            script.setAttribute(key, attr[key])
          })

          document.head.appendChild(script)
        }),

        getCSS: (url, id = false) => new Promise((resolve, reject) => {
          const link = document.createElement('link')
          link.rel = 'stylesheet'
          link.href = url
          if (id) link.id = id
          link.onerror = reject
          link.onload = link.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            link.onload = link.onreadystatechange = null
            resolve()
          }
          document.head.appendChild(link)
        }),

        addGlobalFn: (key, fn, name = false, parent = window) => {
          const pjaxEnable = true
          if (!pjaxEnable && key.startsWith('pjax')) return

          const globalFn = parent.globalFn || {}
          const keyObj = globalFn[key] || {}
    
          if (name && keyObj[name]) return
    
          name = name || Object.keys(keyObj).length
          keyObj[name] = fn
          globalFn[key] = keyObj
          parent.globalFn = globalFn
        }
      }
    
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode
      
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })()</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"7IX3UBC6JW","apiKey":"4ac2846352e499675081f1277fb961c1","indexName":"My Blog","hitsPerPage":6,"languages":{"input_placeholder":"搜索全站文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"本篇文章从发布到现在已经隔了","messageNext":"天了，里面的内容可能过期了，你要自己甄别一下哟👉👈"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":1000,"languages":{"author":"作者: Willow-God","link":"链接: ","source":"来源: LiuShen's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: '/pluginsSrc/@egjs/infinitegrid/dist/infinitegrid.min.js?v=4.12.0',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java课程主要内容回顾',
  isPost: true,
  isHome: false,
  isHighlightShrink: undefined,
  isToc: true,
  postUpdate: '2023-12-21 00:00:00'
}</script><link rel="stylesheet" href="/config/Yozai-Medium/result.css"><link rel="stylesheet" href="/config/memos/memos.css"></head><body><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="/config/swiper/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/config/swiper/swiperstyle.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="LiuShen's Blog" type="application/atom+xml">
<link rel="alternate" href="/rss2.xml" title="LiuShen's Blog" type="application/rss+xml">
<div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div><script async="async">(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }
  
  preloader.initLoading()
  
  let loaded = false;
  
  window.addEventListener('load', () => { 
      if (!loaded) {
          preloader.endLoading();
          loaded = true;
      }
  });

  setTimeout(() => {
      if (!loaded) {
          preloader.endLoading();
          loaded = true;
      }
  }, 5000);

  
  window.addEventListener('load',() => { preloader.endLoading() })
  setTimeout(function(){preloader.endLoading();}, 3000);
  document.getElementById('loading-box').addEventListener('click',()=> {preloader.endLoading()})

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><!--.avatar-img.is-center--><!--  img(src=url_for(theme.avatar.img) onerror=`onerror=null;src='${theme.error_img.flink}'` alt="avatar")--><div class="is-center" id="sidebar-avatar"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.qyliu.top/i/2024/03/21/65fc570ca9fe7.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">Willow-God</div><div class="author-info__description">清羽 〄 飞扬</div></div><div class="site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">52</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">69</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/willow-god"><i class="fab fa-github"></i><span>Follow Me 🛫</span></a><div class="menu-info-social-icons is-center"><a class="social-icon" href="mailto:01@liushen.fun" target="_blank" title="Email"><i class="fa-solid fa-envelope"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=2411457922&amp;site=qq&amp;menu=yes" target="_blank" title="QQ：2411457922"><i class="fa-brands fa-qq"></i></a><a class="social-icon" href="https://wakatime.com/@LiuShen" target="_blank" title="Wakatime"><i class="fa-solid fa-chart-column"></i></a><a class="social-icon" href="https://blog.liushen.fun/atom.xml" target="_blank" title="rss地址"><i class="fa-solid fa-rss"></i></a></div><div class="menus_items visible"><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-home"></i><span> 导航</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/"><i class="fa-fw fa-solid fa-house-laptop"></i><span> 博客主页</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.liushen.fun/"><i class="fa-fw fa-solid fa-house-flag"></i><span> 导航主页</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://xc.liushen.fun/"><i class="fa-fw fa fa-camera-retro"></i><span> 个人相册</span></a></li></ul></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa fa-graduation-cap"></i><span> 整理</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时光卷轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 文章标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 文章分类</span></a></li><li><a class="site-page child" href="/charts/"><i class="fa-fw fa-solid fa-chart-pie"></i><span> 文章通览</span></a></li></ul></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa-solid fa-user-group"></i><span> 友人</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链展示</span></a></li><li><a class="site-page child" href="/addlink/"><i class="fa-fw fa fa-at"></i><span> 友链申请</span></a></li><li><a class="site-page child" href="/fcircle/"><i class="fa-fw fa-solid fa-circle-nodes"></i><span> 朋友动态</span></a></li></ul></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa fa-paper-plane"></i><span> 留言</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/comment/"><i class="fa-fw fa-solid fa-chalkboard"></i><span> 留言白板</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://m.liushen.fun/"><i class="fa-fw fa-solid fa-basketball"></i><span> 盐焗星球</span></a></li></ul></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa-solid fa-stethoscope"></i><span> 服务</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://um.liushen.fun/"><i class="fa-fw fa-solid fa-eye-low-vision"></i><span> 访客统计</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://pan.liushen.fun/"><i class="fa-fw fa-solid fa-laptop-file"></i><span> 资源分享</span></a></li><li><a class="site-page child" href="/subscribe/"><i class="fa-fw fa-solid fa-rss"></i><span> 订阅本站</span></a></li></ul></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa fa-list"></i><span> 关于</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-address-card"></i><span> 站长资料</span></a></li><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-commenting"></i><span> 日常说说</span></a></li><li><a class="site-page child" href="/devices/"><i class="fa-fw fa-solid fa-tachograph-digital"></i><span> 我的设备</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(https://wallpapercave.com/wp/wp7250277.jpg);"><nav id="nav"><span id="blog-info"><a href="/" title="LiuShen's Blog"><span class="site-name">LiuShen's Blog</span></a></span><div id="menus"></div><div class="menus_items visible"><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-home"></i><span> 导航</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/"><i class="fa-fw fa-solid fa-house-laptop"></i><span> 博客主页</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.liushen.fun/"><i class="fa-fw fa-solid fa-house-flag"></i><span> 导航主页</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://xc.liushen.fun/"><i class="fa-fw fa fa-camera-retro"></i><span> 个人相册</span></a></li></ul></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa fa-graduation-cap"></i><span> 整理</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时光卷轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 文章标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 文章分类</span></a></li><li><a class="site-page child" href="/charts/"><i class="fa-fw fa-solid fa-chart-pie"></i><span> 文章通览</span></a></li></ul></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa-solid fa-user-group"></i><span> 友人</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链展示</span></a></li><li><a class="site-page child" href="/addlink/"><i class="fa-fw fa fa-at"></i><span> 友链申请</span></a></li><li><a class="site-page child" href="/fcircle/"><i class="fa-fw fa-solid fa-circle-nodes"></i><span> 朋友动态</span></a></li></ul></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa fa-paper-plane"></i><span> 留言</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/comment/"><i class="fa-fw fa-solid fa-chalkboard"></i><span> 留言白板</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://m.liushen.fun/"><i class="fa-fw fa-solid fa-basketball"></i><span> 盐焗星球</span></a></li></ul></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa-solid fa-stethoscope"></i><span> 服务</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://um.liushen.fun/"><i class="fa-fw fa-solid fa-eye-low-vision"></i><span> 访客统计</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://pan.liushen.fun/"><i class="fa-fw fa-solid fa-laptop-file"></i><span> 资源分享</span></a></li><li><a class="site-page child" href="/subscribe/"><i class="fa-fw fa-solid fa-rss"></i><span> 订阅本站</span></a></li></ul></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa fa-list"></i><span> 关于</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-address-card"></i><span> 站长资料</span></a></li><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-commenting"></i><span> 日常说说</span></a></li><li><a class="site-page child" href="/devices/"><i class="fa-fw fa-solid fa-tachograph-digital"></i><span> 我的设备</span></a></li></ul></div></div><center id="name-container"><a id="page-name" href="javascript:btf.scrollToDest(0, 500)">PAGE_NAME</a></center><div id="nav-right"><div id="travellings"><a class="site-page" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html" title="友链接力-随机开往"><i class="fa-solid fa-bus fa-fw"></i></a></div><div id="ten-years"><a class="site-page" target="_blank" rel="noopener" href="https://foreverblog.cn/go.html" title="友链接力-十年之约"><i class="fa-brands fa-nfc-symbol fa-fw"></i></a></div><div id="random"><a class="site-page" href="javascript:randomPost()" title="随机前往一个文章"><i class="fa-solid fa-shuffle fa-fw"></i></a></div><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i></span></div><div id="toggle-menu"><span class="site-page" href="javascript:void(0);" title="展开菜单"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Java课程主要内容回顾</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-30T16:00:00.000Z" title="发表于 2023-12-01 00:00:00">2023-12-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-20T16:00:00.000Z" title="更新于 2023-12-21 00:00:00">2023-12-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/">学习资料</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>44分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java课程主要内容回顾"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/f7016786/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="考试分数占比"><a href="#考试分数占比" class="headerlink" title="考试分数占比"></a>考试分数占比</h1><p><em>卷A</em></p>
<ul>
<li><strong>单选题</strong>：30道，每题1分</li>
<li><strong>判断题</strong>：10道，每题1分</li>
<li><strong>程序阅读题</strong>：5道，每题6分</li>
<li><strong>编程题</strong>：2道，每题15分</li>
</ul>
<p><em>卷B</em></p>
<ul>
<li><strong>单选题</strong>：20道</li>
<li><strong>判断题</strong>：10道</li>
<li><strong>填空题</strong>：10道</li>
</ul>
<p><strong>成绩占比</strong>：</p>
<ul>
<li><em>平时成绩</em>：30%</li>
<li><em>前七章占比</em>：85%</li>
</ul>
<h1 id="考试重点归纳总结"><a href="#考试重点归纳总结" class="headerlink" title="考试重点归纳总结"></a>考试重点归纳总结</h1><h2 id="第一章：JAVA语言基础背景知识（单选题，判断题，大题不难）"><a href="#第一章：JAVA语言基础背景知识（单选题，判断题，大题不难）" class="headerlink" title="第一章：JAVA语言基础背景知识（单选题，判断题，大题不难）"></a>第一章：JAVA语言基础背景知识（单选题，判断题，大题不难）</h2><ol>
<li><p><strong>Java的发展历史：</strong><br>Java是由Sun Microsystems的工程师James Gosling于20世纪90年代初开发的。起初是为嵌入式系统设计，后来成为一种面向对象的编程语言，以跨平台特性和安全性而著称。</p>
</li>
<li><p><strong>Java的平台：</strong></p>
<ul>
<li><strong>Java SE（Standard Edition）：</strong> 用于桌面应用程序和通用开发。</li>
<li><strong>Java EE（Enterprise Edition）：</strong> 专注于企业级应用程序开发。</li>
<li><strong>Java ME（Micro Edition）：</strong> 用于嵌入式系统和移动设备。</li>
</ul>
</li>
<li><p><strong>平台的作用和特点：</strong></p>
<ul>
<li><strong>Java SE：</strong> 用于通用开发，有丰富的库和API支持，可构建桌面应用。</li>
<li><strong>Java EE：</strong> 针对企业级应用程序开发，包括Web应用和企业系统。</li>
<li><strong>Java ME：</strong> 针对嵌入式系统和移动设备，用于开发针对这些设备的应用程序。</li>
</ul>
</li>
<li><p><strong>Java的特点：</strong></p>
<ul>
<li><strong>跨平台性：</strong> Java的“编写一次，到处运行”特性，可在不同平台上运行。</li>
<li><strong>面向对象：</strong> 支持封装、继承和多态。</li>
<li><strong>自动内存管理：</strong> 具有垃圾回收机制，无需手动管理内存。</li>
<li><strong>安全性：</strong> 提供字节码验证和安全沙箱等安全特性，有助于防止恶意代码执行。</li>
</ul>
</li>
<li><p><strong>与C、C++的异同比较：</strong></p>
<ul>
<li><strong>相同点：</strong> C、C++和Java都是编程语言，具有通用的编程能力。</li>
<li><strong>不同点：</strong><ul>
<li><strong>内存管理：</strong> C、C++需要手动管理内存，而Java有垃圾回收机制。</li>
<li><strong>平台依赖性：</strong> C、C++代码是平台相关的，而Java具有跨平台能力。</li>
<li><strong>语言特性：</strong> C、C++更接近底层，而Java更注重安全性和易用性。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>什么是面向对象：</strong></p>
<ul>
<li>面向对象（Object-Oriented）是一种编程范式，它以对象作为程序设计的基本单元，将数据和操作数据的方法封装在一起。面向对象编程思想使得程序更易于理解、维护和扩展。</li>
</ul>
</li>
<li><p><strong>面型对象的特征：</strong></p>
<ul>
<li><strong>封装（Encapsulation）：</strong> 将数据和操作数据的方法封装在对象内部，只暴露必要的接口给外部使用。这样可以控制数据的访问权限，提高了安全性和灵活性。</li>
<li><strong>继承（Inheritance）：</strong> 允许一个类（子类/派生类）继承另一个类（父类/基类）的属性和方法。子类可以复用父类的特性，减少重复代码，提高了代码的可重用性和扩展性。</li>
<li><strong>多态（Polymorphism）：</strong> 允许不同类的对象对同一消息做出响应，即允许同样的方法调用在不同对象上有不同的行为。多态提高了代码的灵活性和可维护性。</li>
</ul>
</li>
<li><p><strong>实现对象和类的关系：</strong></p>
<ul>
<li><strong>类：</strong> 类是对象的模板，定义了对象的属性和行为。</li>
<li><strong>对象：</strong> 对象是类的实例，包含了类定义的属性和方法。</li>
<li><strong>关系：</strong> 类定义了对象的结构，对象是类的具体实例。在Java中，通过定义类来创建对象，类描述了对象的结构和行为，实例化类可以创建对象，然后使用这些对象调用方法或访问属性。</li>
</ul>
</li>
</ol>
<h2 id="第二章：hello-world，第一个Java程序"><a href="#第二章：hello-world，第一个Java程序" class="headerlink" title="第二章：hello world，第一个Java程序"></a>第二章：hello world，第一个Java程序</h2><ol>
<li><p><strong>一个完整的Java应用程序的组成部分：</strong></p>
<ul>
<li><strong>源代码文件（.java文件）：</strong> 包含程序员编写的Java代码。</li>
<li><strong>类和对象：</strong> Java是面向对象的语言，程序由一个或多个类组成，类描述了对象的属性和行为，对象是类的实例。</li>
<li><strong>主类（Main Class）：</strong> 包含 <code>public static void main(String[] args)</code> 方法的类，作为程序的入口点。</li>
</ul>
</li>
<li><p><strong>public class 和普通类的区别：</strong></p>
<ul>
<li><code>public class</code> 是指公共可访问的类，其类名必须与文件名完全相同。</li>
<li>普通类是包级私有的，只能在同一个包内被访问。</li>
</ul>
</li>
<li><p><strong>文件中有public class时的文件命名：</strong></p>
<ul>
<li>文件名必须与 <code>public class</code> 的类名完全一致，包括大小写。</li>
</ul>
</li>
<li><p><strong>文件中是否可以有多个类或多个public class：</strong></p>
<ul>
<li>一个文件中只能有一个 <code>public class</code>，但可以包含多个普通类。</li>
</ul>
</li>
<li><p><strong>写主函数（psvm）：</strong></p>
<ul>
<li>主函数（<code>main</code> 方法）必须包含在类中，作为程序的入口点。</li>
<li>主函数的声明：<code>public static void main(String[] args)</code>。</li>
</ul>
</li>
<li><p><strong>Java程序的编译和运行：</strong></p>
<ul>
<li>使用 <code>javac</code> 命令编译Java源文件（.java文件），例如：<code>javac YourFileName.java</code>。</li>
<li>使用 <code>java</code> 命令运行编译后的字节码文件（.class文件），例如：<code>java YourCompiledFileName</code>（无后缀）。在运行Java程序时如果需要输入参数，可以在命令行中通过 java 命令后面跟随程序的名称和参数来执行。假设有一个名为 MyProgram 的Java类，它包含了一个 main 方法，可以通过以下方式运行并传递参数：</li>
<li>这里的 <code>arg1</code>, <code>arg2</code>, <code>arg3</code> 是要传递给程序的参数，你可以根据实际需求传入任意数量的参数。在程序中，可以通过 <code>String[]</code> 形参接收传入的参数：</li>
<li>可以通过命令行向主函数传递参数，在程序中通过 <code>args</code> 数组获取。</li>
<li><code>.class</code> 文件中包含了 <code>字节码（Bytecode）</code> 。这些 .class 文件包含了Java源代码编译后的二进制指令，这些指令并不是直接在硬件上执行的机器码，而是Java虚拟机（JVM）可以识别和执行的中间代码。</li>
</ul>
</li>
</ol>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java MyProgram arg1 arg2 arg3 ...</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyProgram</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// args 数组包含了传入的参数</span></span><br><span class="line">        <span class="keyword">for</span> (String arg : args) {</span><br><span class="line">            System.out.println(arg);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ol start="7">
<li><strong>多个class或接口对应的文件数量：</strong><ul>
<li>每个 <code>public class</code> 或普通类会编译成一个对应的 .class 文件。</li>
<li>如果有多个class，编译后会有多个对应的 .class 文件。</li>
<li>如果加了接口，编译后也会有一个对应的 .class 文件。</li>
</ul>
</li>
</ol>
<h2 id="第三章：Java基础概览：数据类型、运算符、程序结构与数组（重点内容）"><a href="#第三章：Java基础概览：数据类型、运算符、程序结构与数组（重点内容）" class="headerlink" title="第三章：Java基础概览：数据类型、运算符、程序结构与数组（重点内容）"></a>第三章：Java基础概览：数据类型、运算符、程序结构与数组<font color="red">（重点内容）</font></h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ol>
<li><p><strong>基本数据类型有哪些？它们的长度是否会根据不同类型而变化？</strong></p>
<ul>
<li>Java的基本数据类型包括：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>float</code>、<code>double</code>、<code>char</code>、<code>boolean</code>。</li>
<li>这些基本数据类型在Java中各自占用的字节数是固定的，不会根据不同数据而变化。比如，<code>int</code>类型一般占用4个字节（32位），<code>double</code>类型一般占用8个字节（64位）。</li>
</ul>
</li>
<li><p><strong>基本数据类型的位数大致是多少？比如整型的取值范围是多大？</strong></p>
<ul>
<li><p><code>byte</code>（8位）、<code>short</code>（16位）、<code>int</code>（32位）、<code>long</code>（64位）、<code>float</code>（32位）、<code>double</code>（64位）、<code>char</code>（16位，Unicode字符）、<code>boolean</code>（未定义）。</p>
</li>
<li><p>整型的取值范围：</p>
</li>
<li><p><code>byte</code>：8位，范围为 -128 到 127</p>
</li>
<li><p><code>short</code>：16位，范围为 -32768 到 32767</p>
</li>
<li><p><code>int</code>：32位，范围为 -2147483648 到 2147483647</p>
</li>
<li><p><code>long</code>：64位，范围为 -9223372036854775808 到 9223372036854775807</p>
</li>
</ul>
</li>
</ol>
<h3 id="引用类型和类型转换"><a href="#引用类型和类型转换" class="headerlink" title="引用类型和类型转换"></a>引用类型和类型转换</h3><ol start="3">
<li><p><strong>除了基本数据类型外，Java中还有哪些引用类型？</strong></p>
<ul>
<li><strong>类（Class）</strong>：是面向对象编程的基础，用于描述对象的属性和行为。</li>
<li><strong>接口（Interface）</strong>：定义了一组方法的集合，但没有具体的实现，通过实现接口的类来提供方法的具体实现。</li>
<li><strong>数组（Array）</strong>：可以存储多个相同类型的元素的数据结构。</li>
<li><strong>枚举（Enum）</strong>：表示一组固定的常量，限定了变量的取值范围。</li>
<li><strong>String</strong>：用于表示文本字符串的引用类型。</li>
<li><strong>集合框架（Collection Framework）</strong>：包括List、Set、Queue和Map等各种数据结构，用于存储和操作对象的集合。</li>
<li><strong>自定义引用类型</strong>：通过类或接口定义的自定义数据类型。</li>
<li>在Java中，除了基本数据类型（如int、double等），大部分类型都属于引用类型。这些引用类型允许开发者更灵活地处理数据和对象，并且它们在内存中存储的是对象的引用或地址，而不是实际的数据值。</li>
</ul>
</li>
<li><p><strong>基本数据类型之间可以进行哪些类型转换？自动转换、隐式转换、强制转换的区别是什么？</strong></p>
<ul>
<li>基本数据类型之间可以进行自动转换（从小范围类型到大范围类型），例如 <code>int</code> 转换为 <code>long</code>。</li>
<li>隐式转换是指在程序编译期间由编译器自动完成的类型转换，确保转换不会造成数据丢失或错误。</li>
<li>强制转换是指开发者手动进行的类型转换，需要注意可能会发生数据丢失或溢出的情况。</li>
</ul>
</li>
<li><p><strong>在Java中，默认的整型和浮点型的字面量分别是什么？</strong></p>
<ul>
<li>整型的默认字面量是 <code>int</code> 类型，浮点型的默认字面量是 <code>double</code> 类型。</li>
</ul>
</li>
</ol>
<h3 id="定义变量和常量，注释"><a href="#定义变量和常量，注释" class="headerlink" title="定义变量和常量，注释"></a>定义变量和常量，注释</h3><ol start="6">
<li><p><strong>变量的标识符由什么组成？合法和非法的标识符有哪些？</strong></p>
<ul>
<li>变量的标识符由字母、数字、下划线和美元符号组成，但不能以数字开头，还有关键词也不行。</li>
<li>合法的标识符示例：<code>myVar</code>、<code>_value</code>、<code>age123</code>。</li>
<li>非法的标识符示例：<code>123var</code>、<code>my-Var</code>、<code>$money#</code>。</li>
</ul>
</li>
<li><p><strong>在Java中，如何定义变量和常量？</strong></p>
<ul>
<li><p><strong>定义变量：</strong> 使用关键字和标识符，例如 <code>int myVar;</code> 或 <code>String name = "John";</code>。</p>
</li>
<li><p><strong>定义常量：</strong> 使用 <code>final</code> 关键字，例如 <code>final double PI = 3.14;</code>。</p>
</li>
<li><p><strong>静态成员：</strong> 使用 <code>static</code> 关键字创建类级别的变量、方法或静态块。静态变量属于类，与对象实例无关，而静态方法可通过类名直接调用。静态块是在类加载时执行的代码块，用于执行静态变量的初始化或其他类加载时需要执行的逻辑。</p>
 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 静态变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printMessage</span><span class="params">()</span> { <span class="comment">// 静态方法</span></span><br><span class="line">        System.out.println(<span class="string">"Hello, World!"</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        <span class="comment">// 静态块</span></span><br><span class="line">        System.out.println(<span class="string">"This is a static block."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li><p><strong>Java中的注释有哪些类型？如何书写这些注释？</strong></p>
<ul>
<li>单行注释：使用 <code>//</code>，例如 <code>// 这是单行注释</code>。</li>
<li>多行注释：使用 <code>/* */</code>，例如 <code>/* 这是多行注释 */</code>。</li>
<li>文档注释：以 <code>/** */</code> 开始，通常用于生成API文档，例如：<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是文档注释，描述方法或类的作用</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ol>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ol start="9">
<li><p><strong>Java中的运算符分为哪几种类型？一元运算符和二元运算符的例子有哪些？</strong></p>
<ul>
<li>Java中的运算符分为算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符等。</li>
<li>一元运算符示例：负号 <code>-</code>，递增 <code>++</code>，递减 <code>--</code>。</li>
<li>二元运算符示例：加法 <code>+</code>，减法 <code>-</code>，乘法 <code>*</code>，除法 <code>/</code>，取模 <code>%</code>。</li>
<li>三元运算符示例：只有一个： <code> ？ ：</code></li>
</ul>
</li>
<li><p><strong>算术运算符的特点是什么？在整数相除时会发生什么？</strong></p>
</li>
</ol>
<ul>
<li>算术运算符包括加法 <code>+</code>、减法 <code>-</code>、乘法 <code>*</code>、除法 <code>/</code>、取模 <code>%</code>。</li>
<li>在整数相除时，如果两个整数相除，结果也是整数，小数部分会被舍弃，需要重点注意一下。</li>
</ul>
<ol start="11">
<li><strong>关系运算符的种类有哪些？Java中的等于运算符存在什么问题？</strong></li>
</ol>
<ul>
<li>关系运算符包括大于 <code>&gt;</code>、小于 <code>&lt;</code>、大于等于 <code>&gt;=</code>、小于等于 <code>&lt;=</code>、等于 <code>==</code>、不等于 <code>!=</code>。</li>
<li>在Java中，<code>==</code> 运算符用于比较两个对象引用（即内存中对象的地址）是否相同，而不是比较对象的内容是否相同。当使用 <code>==</code> 比较两个对象引用时：<ul>
<li>如果比较的是基本数据类型（如 <code>int</code>, <code>char</code>, <code>double</code> 等），则比较的是它们的值。</li>
<li>如果比较的是引用类型（如对象），则比较的是对象的引用，即对象在内存中的地址。</li>
<li><code>==</code> 比较的是对象的引用地址，而 <code>.equals()</code> 方法则是根据对象的内容来进行比较。</li>
<li>如果想要比较两个对象的内容是否相同，应该使用 <code>.equals()</code> 方法（对于自定义类需要覆盖 <code>equals()</code> 方法以适应对象内容的比较），示例：<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">"Hello"</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"Hello"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(str1 == str2);  <span class="comment">// 这里将输出 false，因为str1和str2引用不同的对象</span></span><br><span class="line">System.out.println(str1.equals(str2)); <span class="comment">// 这里将输出 true，因为使用了equals()方法比较的是内容是否相同</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ul>
<ol start="12">
<li><p><strong>自增自减运算符放在前面和后面的区别是什么？</strong></p>
<ul>
<li><code>++i</code>（前置自增）会先进行自增操作，然后再使用变量。</li>
<li><code>i++</code>（后置自增）会先使用变量，然后再进行自增操作。</li>
<li>下面是一些例题：</li>
<li>在Java中，<code>++</code> 和 <code>--</code> 运算符的行为取决于它们的位置，前置和后置的区别。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">5000</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> (i++) + (i++) + (i++); <span class="comment">// 此行代码的结果是多少？</span></span><br><span class="line">System.out.println(result); <span class="comment">// 结果为 15003</span></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<ul>
<li><p>解释：</p>
<ul>
<li><code>i++</code> 是后置自增运算符，它先返回 <code>i</code> 的当前值（5000），然后将 <code>i</code> 的值加一。</li>
<li>在 <code>result</code> 的计算中，第一个 <code>(i++)</code> 返回的是 <code>i</code> 的当前值5000，此时 <code>i</code> 变为5001。</li>
<li>第二个 <code>(i++)</code> 返回的是 <code>i</code> 的当前值5001，此时 <code>i</code> 变为5002。</li>
<li>第三个 <code>(i++)</code> 返回的是 <code>i</code> 的当前值5002，此时 <code>i</code> 变为5003。</li>
<li>最后将这三个返回值相加，即 <code>5000 + 5001 + 5002 = 15003</code>。</li>
</ul>
</li>
<li><p>类似的例子：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a++ + ++a + a++; <span class="comment">// 结果是多少？</span></span><br><span class="line">System.out.println(b); <span class="comment">// 结果是 34</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>解释：</p>
<ul>
<li><code>a++</code> 返回值为 <code>10</code>，此时 <code>a</code> 变成 <code>11</code>。</li>
<li><code>++a</code> 返回值为 <code>12</code>，此时 <code>a</code> 变成 <code>12</code>。</li>
<li><code>a++</code> 返回值为 <code>12</code>，此时 <code>a</code> 变成 <code>13</code>。</li>
<li>然后将 <code>10 + 12 + 12 = 34</code>。</li>
</ul>
</li>
</ul>
<h3 id="逻辑、位运算和优先级"><a href="#逻辑、位运算和优先级" class="headerlink" title="逻辑、位运算和优先级"></a>逻辑、位运算和优先级</h3><ol start="13">
<li><p><strong>逻辑运算符和位运算符有什么作用？</strong></p>
<ul>
<li><p>逻辑运算符用于逻辑表达式，包括逻辑与 <code>&amp;&amp;</code>、逻辑或 <code>||</code>、逻辑非 <code>!</code> 等，用于布尔值的操作。</p>
</li>
<li><p>位运算符用于对整数的二进制位进行操作，包括按位与 <code>&amp;</code>、按位或 <code>|</code>、按位异或 <code>^</code> 等，用于位级操作。</p>
</li>
<li><p>在Java中，<code>&amp;</code> 和 <code>|</code> 是按位与和按位或运算符，而 <code>&amp;&amp;</code> 和 <code>||</code> 是逻辑与和逻辑或运算符。</p>
</li>
<li><p>**按位与 <code>&amp;</code> 和逻辑与 <code>&amp;&amp;</code>**：</p>
<ul>
<li><code>&amp;</code> 执行按位与操作，对两个操作数的每一位执行与操作。</li>
<li><code>&amp;&amp;</code> 执行逻辑与操作，对两个布尔表达式进行短路求值，即如果第一个表达式为 <code>false</code>，则不再计算第二个表达式。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>; <span class="comment">// 二进制：0101</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>; <span class="comment">// 二进制：0011</span></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a &amp; b; <span class="comment">// 按位与操作：0001 (结果为1)</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">d</span> <span class="operator">=</span> (a &lt; b) &amp;&amp; (a != <span class="number">0</span>); <span class="comment">// 逻辑与操作：false (因为a &lt; b为false)</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>**按位或 <code>|</code> 和逻辑或 <code>||</code>**：<ul>
<li><code>|</code> 执行按位或操作，对两个操作数的每一位执行或操作。</li>
<li><code>||</code> 执行逻辑或操作，对两个布尔表达式进行短路求值，即如果第一个表达式为 <code>true</code>，则不再计算第二个表达式。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>; <span class="comment">// 二进制：0101</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>; <span class="comment">// 二进制：0011</span></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a | b; <span class="comment">// 按位或操作：0111 (结果为7)</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">d</span> <span class="operator">=</span> (a &gt; b) || (b != <span class="number">0</span>); <span class="comment">// 逻辑或操作：true (因为a &gt; b为true)</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>区别：<ul>
<li>按位与和按位或是对两个操作数的每一位执行位操作，无论操作数的类型是整数还是布尔值都会执行位运算。</li>
<li>逻辑与和逻辑或是对两个布尔表达式进行逻辑运算，并且具有短路求值的特性，根据第一个表达式的结果来决定是否计算第二个表达式。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Java中各个运算符的优先级大致是怎样的？</strong></p>
<ul>
<li>运算符有不同的优先级，例如算术运算符优先级高于关系运算符，逻辑运算符等。</li>
<li>优先级高的运算符会先于优先级低的运算符进行计算。</li>
<li>下面是运算符优先级表，从上往下从高到低，在表格中越靠上的运算符优先级越高，在表达式中会优先执行：</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>()</code></td>
<td>圆括号</td>
</tr>
<tr>
<td><code>++</code>, <code>--</code></td>
<td>后缀递增/递减</td>
</tr>
<tr>
<td><code>+</code>, <code>-</code></td>
<td>正号、负号</td>
</tr>
<tr>
<td><code>!</code>, <code>~</code></td>
<td>逻辑非、按位取反</td>
</tr>
<tr>
<td><code>*</code>, <code>/</code>, <code>%</code></td>
<td>乘法、除法、取模</td>
</tr>
<tr>
<td><code>+</code>, <code>-</code></td>
<td>加法、减法</td>
</tr>
<tr>
<td><code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code></td>
<td>左移、右移、无符号右移</td>
</tr>
<tr>
<td><code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>instanceof</code></td>
<td>小于、小于等于、大于、大于等于、instanceof</td>
</tr>
<tr>
<td><code>==</code>, <code>!=</code></td>
<td>等于、不等于</td>
</tr>
<tr>
<td><code>&amp;</code></td>
<td>按位与</td>
</tr>
<tr>
<td><code>^</code></td>
<td>按位异或</td>
</tr>
<tr>
<td><code>|</code></td>
<td>按位或</td>
</tr>
<tr>
<td><code>&amp;&amp;</code></td>
<td>逻辑与</td>
</tr>
<tr>
<td><code>||</code></td>
<td>逻辑或</td>
</tr>
<tr>
<td><code>? :</code></td>
<td>条件运算符</td>
</tr>
<tr>
<td><code>=</code>, <code>+=</code>, <code>-=</code>，<code>*=</code>, <code>/=</code>, <code>%=</code></td>
<td>赋值运算符及组合赋值运算符</td>
</tr>
</tbody></table>
<h3 id="赋值运算符和程序结构"><a href="#赋值运算符和程序结构" class="headerlink" title="赋值运算符和程序结构"></a>赋值运算符和程序结构</h3><ol start="15">
<li><p><strong>赋值运算符的作用是什么？Java中可以进行连续赋值吗？</strong></p>
<ul>
<li>赋值运算符用于将右侧的值赋给左侧的变量，例如 <code>int x = 10;</code>。</li>
<li>Java中可以进行连续赋值，例如 <code>int a = b = c = 10;</code>，这里的值会从右向左依次赋给变量。</li>
</ul>
</li>
<li><p><strong>程序运行的结构是怎样的？在Java中，循环和判断结构是如何使用的？</strong></p>
<ul>
<li>程序运行是从上到下依次执行的，遇到循环、判断等控制结构会按照条件进行分支执行。</li>
<li>顺序结构（Sequence Structure）：按照代码的书写顺序一行一行地执行，从上到下顺序执行代码。这是最基本的程序执行方式，代码按照写入的顺序依次执行。</li>
<li>选择结构（Selection Structure）：根据条件选择性地执行代码块。主要有 if-else 语句、switch 语句等。根据条件的真假执行不同的代码分支。<ul>
<li><p>当使用 <code>switch</code> 语句时，有一些注意事项：</p>
<ol>
<li><p><strong>括号中变量的要求</strong>：<code>switch</code> 后面的括号中必须是一个可以转换为整数的表达式或者变量，比如整数、字符、枚举或者可以自动转换为整数的表达式。</p>
</li>
<li><p><strong>case</strong>：<code>case</code> 是用于匹配值的标签。当 <code>switch</code> 中的变量与 <code>case</code> 后的值匹配时，程序会从匹配的 <code>case</code> 开始执行。注意，<code>case</code> 中的值必须是常量表达式，不允许使用变量。</p>
</li>
<li><p><strong>break</strong>：<code>break</code> 语句用于跳出 <code>switch</code> 语句。如果不在 <code>case</code> 后使用 <code>break</code>，程序将继续执行下一个 <code>case</code> 直到遇到 <code>break</code> 或 <code>switch</code> 结束。</p>
</li>
<li><p><strong>default</strong>：<code>default</code> 是可选的，用于处理 <code>switch</code> 中没有匹配到任何 <code>case</code> 值的情况。它类似于 <code>if-else</code> 结构中的 <code>else</code>，处理除了 <code>case</code> 中列出的值之外的情况。</p>
</li>
</ol>
</li>
<li><p>总的来说，<code>switch</code> 语句中的每个 <code>case</code> 应该以 <code>break</code> 结束，以避免执行后续的 <code>case</code>。而 <code>default</code> 是可选的，用于处理未匹配到 <code>case</code> 值的情况。</p>
</li>
</ul>
</li>
<li>循环结构（Loop Structure）：重复执行一段代码，直到满足退出条件为止。主要有 for 循环、while 循环、do-while 循环等。根据条件重复执行代码块，直到条件不再满足。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">switch</span> (num) {</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment">// 执行语句</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="comment">// 执行语句</span></span><br><span class="line">        <span class="comment">// 注意：如果没有 break，程序会继续执行下面的 case，直到遇到 break 或 switch 结束</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 默认情况，如果上面的 case 都不匹配，则执行 default 中的语句</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</li>
<li><p><strong>在switch语句中，变量的要求是什么？break和default的作用分别是什么？</strong></p>
<ul>
<li><code>switch</code> 语句中的变量可以是整数类型（<code>int</code>、<code>byte</code>、<code>short</code>、<code>char</code>）或枚举类型。</li>
<li><code>break</code> 用于退出 <code>switch</code> 语句，防止继续执行其他 <code>case</code> 或 <code>default</code> 分支。</li>
<li><code>default</code> 是 <code>switch</code> 语句中的默认分支，用于当没有匹配的 <code>case</code> 时执行。</li>
</ul>
</li>
</ol>
<h3 id="循环和控制语句"><a href="#循环和控制语句" class="headerlink" title="循环和控制语句"></a>循环和控制语句</h3><ol start="18">
<li><p><strong>for循环的三段分号的作用是什么？while和do-while循环的逻辑区别是什么？</strong></p>
<ul>
<li><code>for</code> 循环的三段分号分别是初始化语句、循环条件、循环后操作，它们分别在进入循环前、每次循环前和每次循环后执行。</li>
<li><code>while</code> 循环在循环开始前先判断条件是否成立，如果不成立，则一次都不执行。<code>do-while</code> 循环则是先执行一次循环体，再判断条件是否成立。</li>
</ul>
</li>
<li><p><strong>continue和break在循环中的作用是什么？带标签的break有什么用途？</strong></p>
<ul>
<li><code>continue</code> 用于跳过循环体内剩余的代码，直接进入下一次循环。</li>
<li><code>break</code> 用于完全退出当前循环结构，不再执行循环体内的代码。</li>
<li>带标签的 <code>break</code> 可以用于退出嵌套循环，可以指定要退出的是哪一个循环。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// 使用 continue 跳过偶数并打印奇数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) {</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">continue</span>; <span class="comment">// 跳过偶数</span></span><br><span class="line">    }</span><br><span class="line">    System.out.print(i + <span class="string">" "</span>); <span class="comment">// 打印奇数</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">// 输出结果：1 3 5 7 9</span></span><br><span class="line"></span><br><span class="line">System.out.println(); <span class="comment">// 换行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 break 完全退出循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) {</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span>) {</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 当 i 等于 5 时退出循环</span></span><br><span class="line">    }</span><br><span class="line">    System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 输出结果：1 2 3 4</span></span><br><span class="line"></span><br><span class="line">System.out.println(); <span class="comment">// 换行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带标签的 break 用于退出嵌套循环</span></span><br><span class="line">outerLoop: <span class="comment">// 外部循环标签</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">3</span>; j++) {</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">2</span> &amp;&amp; j == <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">break</span> outerLoop; <span class="comment">// 当 i 和 j 均为 2 时退出外部循环</span></span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"i = "</span> + i + <span class="string">", j = "</span> + j);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ol start="20">
<li><p><strong>数组的定义和元素组成是怎样的？在Java中，数组长度是否可以变化？</strong></p>
<ul>
<li>数组是具有相同数据类型的元素的集合，在Java中用方括号 <code>[]</code> 定义，例如 <code>int[] numbers = new int[5];</code>。</li>
<li>数组的元素可以是基本数据类型或对象类型。</li>
<li>在Java中，一旦数组被创建，其长度就是固定的，无法直接改变。</li>
</ul>
</li>
<li><p><strong>如何访问数组中的元素？数组的初始化方式有哪些？</strong></p>
<ul>
<li>可以通过索引（下标）访问数组中的元素，索引从0开始计数。</li>
<li>数组可以使用大括号 <code>{}</code> 进行初始化，例如 <code>int[] numbers = {1, 2, 3, 4, 5};</code>。</li>
</ul>
</li>
<li><p><strong>一维数组和多维数组有什么区别？数组元素的赋值方式是怎样的？</strong></p>
<ul>
<li>一维数组是一个线性的数据结构，而多维数组是数组的数组，例如二维数组 <code>int[][] matrix = new int[3][3];</code>。</li>
<li>数组元素的赋值可以通过索引直接赋值，例如 <code>numbers[0] = 10;</code>。</li>
</ul>
</li>
<li><p>数组的展示：</p>
<ul>
<li><code>numbers</code> 是一个包含5个整数的一维数组，<code>names</code> 是一个包含3个字符串的一维数组。</li>
<li>通过 <code>numbers[0]</code> 和 <code>numbers[1]</code> 可以访问并设置数组的第一个和第二个元素。</li>
<li><code>initializedArray</code> 是使用大括号初始化的一维数组。</li>
<li><code>matrix</code> 是一个3x3的二维数组，通过 <code>[i][j]</code> 访问不同行和列的元素，并对其进行赋值。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组的定义和元素组成</span></span><br><span class="line"><span class="type">int</span>[] numbers = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>]; <span class="comment">// 定义一个包含5个整数的数组</span></span><br><span class="line">String[] names = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">3</span>]; <span class="comment">// 定义一个包含3个字符串的数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问数组中的元素</span></span><br><span class="line">numbers[<span class="number">0</span>] = <span class="number">10</span>; <span class="comment">// 设置数组第一个元素为10</span></span><br><span class="line">numbers[<span class="number">1</span>] = <span class="number">20</span>; <span class="comment">// 设置数组第二个元素为20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组的初始化方式</span></span><br><span class="line"><span class="type">int</span>[] initializedArray = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>}; <span class="comment">// 使用大括号初始化数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多维数组</span></span><br><span class="line"><span class="type">int</span>[][] matrix = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">3</span>]; <span class="comment">// 定义一个3x3的二维数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组元素的赋值方式</span></span><br><span class="line">matrix[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 第一行第一列的元素赋值为1</span></span><br><span class="line">matrix[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">2</span>; <span class="comment">// 第二行第二列的元素赋值为2</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="第四章：Java面向对象编程基础探索"><a href="#第四章：Java面向对象编程基础探索" class="headerlink" title="第四章：Java面向对象编程基础探索"></a>第四章：Java面向对象编程基础探索</h2><h3 id="类中的成员变量和方法定义"><a href="#类中的成员变量和方法定义" class="headerlink" title="类中的成员变量和方法定义"></a>类中的成员变量和方法定义</h3><ol>
<li><strong>类怎么定义，成员变量或字段或属性的定义，赋初值，如果没有赋值初始值，能否直接使用？</strong><ul>
<li><p>在Java中，定义一个类包括以下几个部分：</p>
</li>
<li><p>类的定义</p>
</li>
<li><p>在类中定义的变量被称为成员变量、字段或属性。示例中的 <code>myField</code> 就是一个私有的整型成员变量。这些变量可以使用不同的访问修饰符来控制其可见性和访问权限，比如 <code>private</code>、<code>public</code>、<code>protected</code> 等。</p>
</li>
<li><p>如果没有显式赋值初始值，Java会为基本数据类型的成员变量赋予默认值，而不是null。如下：</p>
<ul>
<li><code>int</code> 类型的默认值为 <code>0</code></li>
<li><code>boolean</code> 类型的默认值为 <code>false</code></li>
<li><code>double</code> 类型的默认值为 <code>0.0</code></li>
<li>对象类型的默认值为 <code>null</code></li>
</ul>
</li>
<li><p>在Java中，如果没有给成员变量赋值初始值，它们仍然会被分配默认值，因此可以直接使用。但是，这可能会导致意想不到的结果，因此最好在使用前为其赋予合适的初值，以避免不确定的情况发生。</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> {</span><br><span class="line">    <span class="comment">// 成员变量/字段/属性的定义</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> myField; <span class="comment">// 声明一个私有的整型成员变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 构造方法</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 方法体</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ol start="2">
<li><strong>方法的定义和方法头是什么？方法的签名和参数声明方式是怎样的？方法可以重名吗？</strong><ul>
<li>方法是类中的函数，由返回类型、方法名、参数列表和方法体组成。方法的签名由方法名和参数列表组成，用于唯一标识一个方法。参数声明指定了方法接受的参数类型和参数名。</li>
<li>在Java中，方法可以拥有相同的名称但具有不同的参数列表，这就是方法的重载（Overloading）。方法重载允许在同一个类中定义多个具有相同名称但参数列表不同的方法。参数列表不同可以通过以下方式之一进行区分：<ul>
<li>参数个数不同</li>
<li>参数类型不同</li>
<li>参数顺序不同</li>
</ul>
</li>
<li>举例来说，下面这两个方法就构成了重载：</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">(<span class="type">int</span> num)</span> {</span><br><span class="line">        <span class="comment">// 执行一些操作</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">(<span class="type">double</span> num)</span> {</span><br><span class="line">        <span class="comment">// 执行一些不同的操作，参数类型不同</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol start="3">
<li><p><strong>方法的调用以及对基本类型和引用类型的参数传递方式？</strong></p>
<ul>
<li>方法的调用使用方法名和参数列表，传递参数可以是基本类型或引用类型。基本类型参数是按值传递，传递的是值的拷贝，而引用类型参数传递的是引用的地址。</li>
</ul>
</li>
<li><p><strong>方法的返回值，void和有返回值的情况下如何使用return？</strong></p>
<ul>
<li>方法可以有返回值，也可以没有（使用<code>void</code>）。有返回值的方法使用<code>return</code>关键字返回结果，<code>void</code>方法不返回任何值。</li>
</ul>
</li>
<li><p><strong>一个函数能否有多个return语句？参数表的不同情况会怎样影响方法的识别？</strong></p>
<ul>
<li>一个函数可以有多个<code>return</code>语句，但只有一个会被执行。方法的识别取决于方法名和参数列表的唯一性。</li>
</ul>
</li>
<li><p><strong>函数重载和传入不同类型参数对方法的影响？</strong></p>
<ul>
<li>函数重载是指在同一个类中，方法名相同但参数列表不同的多个方法。传入不同类型参数会根据参数的数量、顺序、类型来调用相应的方法。</li>
</ul>
</li>
<li><p><strong>函数在使用时，对于基本类型参数和引用类型参数的调用和实际使用赋值是怎么样的？</strong></p>
<ul>
<li><p>函数在使用时对于基本类型参数和引用类型参数的处理方式有所不同：</p>
</li>
<li><p>1、基本类型参数（如 int、double 等）</p>
<ol>
<li><strong>调用方式：</strong> 传递的是参数的值。</li>
<li><strong>实际使用：</strong> 在函数中对参数的任何修改不会影响到原始值。因为基本类型参数传递的是值的拷贝，函数中对参数的操作只影响到了拷贝的值。</li>
</ol>
</li>
<li><p>2、引用类型参数（如对象）</p>
<ol>
<li><strong>调用方式：</strong> - 传递的是对象的引用（地址）。</li>
<li><strong>实际使用：</strong> - 在函数中对对象的内容的修改会影响到原始对象，因为传递的是引用，指向同一个对象。修改引用指向的内容会反映在原始对象上。</li>
</ol>
</li>
<li><p>基本类型参数传递的是值的拷贝，函数内部对参数的修改不影响原始值；而引用类型参数传递的是引用（地址），对参数所指向对象的修改会影响到原始对象。</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">manipulatePrimitive</span><span class="params">(<span class="type">int</span> num)</span> {</span><br><span class="line">    num = num * <span class="number">2</span>; <span class="comment">// 对参数进行修改，但不影响原始值</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    manipulatePrimitive(value);</span><br><span class="line">    System.out.println(value); <span class="comment">// 输出仍然是 10，原始值未改变</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> {</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    </span><br><span class="line">    MyClass(<span class="type">int</span> number) {</span><br><span class="line">        <span class="built_in">this</span>.number = number;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">manipulateReference</span><span class="params">(MyClass obj)</span> {</span><br><span class="line">    obj.number = obj.number * <span class="number">2</span>; <span class="comment">// 修改对象内容，会影响原始对象</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    <span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>(<span class="number">5</span>);</span><br><span class="line">    manipulateReference(obj);</span><br><span class="line">    System.out.println(obj.number); <span class="comment">// 输出是 10，原始对象被修改</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<h3 id="构造方法和类的继承"><a href="#构造方法和类的继承" class="headerlink" title="构造方法和类的继承"></a>构造方法和类的继承</h3><ol start="8">
<li><p><strong>构造方法与类同名，无返回值。构造方法可以重载吗？一个类可以有多个构造方法吗？</strong></p>
<ul>
<li>构造方法与类同名，没有返回值。构造方法可以重载，即在同一个类中可以有多个构造方法，它们具有不同的参数列表，参数表为空的，叫缺省构造方法。</li>
</ul>
</li>
<li><p><strong>没有提供构造方法时编译器会自动添加构造方法，构造方法之间的相互调用需要使用关键字吗？</strong></p>
<ul>
<li>当类中没有显式提供构造方法时，编译器会自动生成默认的无参构造方法。构造方法之间的相互调用可以使用<code>this</code>关键字，用于调用同一个类中的其他构造方法。<code>this</code> 关键字在Java中扮演着多重角色。它代表当前对象的引用，允许在类的方法中访问成员变量和方法。这种引用的灵活性让代码更清晰易读。此外，<code>this</code> 还能够在构造方法中调用其他构造方法，减少代码冗余，并作为方法返回值返回当前对象。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">(<span class="type">int</span> number)</span> {</span><br><span class="line">        <span class="built_in">this</span>.number = number; <span class="comment">// 使用 this 引用成员变量</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printNumber</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.number); <span class="comment">// 在方法中使用 this 引用成员变量</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MyClass <span class="title function_">increment</span><span class="params">()</span> {</span><br><span class="line">        <span class="built_in">this</span>.number++; <span class="comment">// 使用 this 在方法中操作成员变量</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>; <span class="comment">// 返回当前对象</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">anotherMethod</span><span class="params">()</span> {</span><br><span class="line">        <span class="built_in">this</span>.increment(); <span class="comment">// 在方法中调用其他方法</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<ol start="10">
<li><strong>关于继承，子类如何表达对父类的继承？继承关系中子类继承了什么？</strong><ul>
<li>子类通过<code>extends</code>关键字表达对父类的继承。继承关系中，子类继承了父类的非私有成员变量和方法。</li>
<li>在Java中，子类和父类之间是一种继承关系。这种关系是单一继承的，意味着一个类只能直接继承自一个父类。</li>
<li>继承关系有如下特点：<ul>
<li>继承性：子类继承了父类的特性，可以访问父类的非私有成员变量和方法。</li>
<li>派生性：子类可以在继承的基础上拓展，增加新的成员变量和方法。</li>
<li>多态性：子类对象可以被当做父类对象使用，这是多态性的一种表现。</li>
<li>父子关系：子类是父类的扩展，拥有父类的属性和行为。</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Animal is eating."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Dog is barking."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        dog.eat();  <span class="comment">// 子类对象能够调用父类的方法</span></span><br><span class="line">        dog.bark(); <span class="comment">// 子类对象可以调用自己独有的方法</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol start="11">
<li><strong>多层继承结构中创建子类对象是否需要调用父类对象？super关键字的作用？</strong><ul>
<li><p>在多层继承中，创建子类对象不需要直接调用父类对象。<code>super</code>关键字用于在子类中访问父类的成员变量或调用父类的构造方法。<br>在Java中，显示调用和隐式调用通常指的是在继承关系中，子类对父类方法的调用方式。</p>
</li>
<li><p><strong>显示调用（Explicit Invocation）：</strong> 子类调用父类的方法时，使用 <code>super</code> 关键字显式指明调用的是父类的方法。这种调用方式明确指示了调用的是父类的特定方法。</p>
</li>
<li><p><strong>隐式调用（Implicit Invocation）：</strong> 子类调用父类的方法时，如果没有使用 <code>super</code> 关键字，系统会默认调用父类的对应方法（如果子类没有重写该方法）。这种调用方式不明确指示调用的是父类的方法，而是隐含地依赖于继承关系。</p>
</li>
<li><p>在这个例子中，<code>makeSound()</code> 方法在 <code>Dog</code> 类中被重写了。<code>performSound()</code> 方法内部调用 <code>makeSound()</code> 方法时，没有显式使用 <code>super</code> 关键字，因此隐式调用的是子类 <code>Dog</code> 的 <code>makeSound()</code> 方法。</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Animal makes a sound"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> {</span><br><span class="line">        <span class="built_in">super</span>.makeSound(); <span class="comment">// 显式调用父类方法</span></span><br><span class="line">        System.out.println(<span class="string">"Dog barks"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Animal makes a sound"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">performSound</span><span class="params">()</span> {</span><br><span class="line">        makeSound(); <span class="comment">// 隐式调用父类方法</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol start="12">
<li><strong>方法的覆盖和重载，以及子类和父类之间相互转换？</strong><ul>
<li><p>覆盖（Override）和重载（Overload）是Java中两个不同的概念，用于描述方法的行为。</p>
</li>
<li><p>1、覆盖（Override）：</p>
<ul>
<li><strong>定义：</strong> 在继承关系中，子类可以对父类的方法进行覆盖，也就是在子类中重新实现（重写）父类的方法。子类中的方法签名必须与父类中被覆盖的方法相同（方法名、参数列表和返回类型完全一致）。</li>
<li><strong>目的：</strong> 允许子类提供自己的实现，替换父类的方法实现。这使得在运行时，调用子类对象的该方法时会执行子类的实现，而不是父类的实现。</li>
<li><strong>发生条件：</strong> 子类覆盖父类方法必须保持方法签名一致，否则编译器将不会识别为覆盖。</li>
</ul>
</li>
<li><p>2、重载（Overload）：</p>
<ul>
<li><strong>定义：</strong> 在同一个类中，可以定义多个方法，这些方法具有相同的名称但是参数列表不同（参数类型、参数个数或者参数顺序不同）。</li>
<li><strong>目的：</strong> 允许使用相同的方法名来提供不同的行为。Java编译器根据不同的方法签名来区分并调用适当的方法。</li>
<li><strong>发生条件：</strong> 方法名称相同，但参数列表必须不同。</li>
</ul>
</li>
<li><p>3、异同点：</p>
<ul>
<li><p><strong>相同点：</strong></p>
<ul>
<li>都涉及方法的名称和参数列表。</li>
<li>都可以让程序员提供不同的实现方式。</li>
</ul>
</li>
<li><p><strong>不同点：</strong></p>
<ul>
<li>覆盖是子类重写父类中的方法，方法签名必须一致；重载是在同一个类中，方法名相同但方法签名不同。</li>
<li>覆盖发生在继承关系中，重载发生在同一个类中。</li>
<li>覆盖只能通过子类覆盖父类的方法；重载可以在同一个类中定义多个具有相同名称但不同参数列表的方法。</li>
</ul>
</li>
</ul>
</li>
<li><p>总体来说，覆盖是方法的多态性表现，重载是方法的多样性表现。覆盖允许子类提供自己的实现以替代父类方法，而重载允许在同一个类中提供多个同名但不同参数列表的方法。</p>
</li>
</ul>
</li>
</ol>
<h3 id="包、访问控制符、static"><a href="#包、访问控制符、static" class="headerlink" title="包、访问控制符、static"></a>包、访问控制符、static</h3><ol start="13">
<li><strong>包的引入方式和package、import的使用顺序？Java的访问控制符有哪些？</strong><ul>
<li><p>包的引入使用<code>package</code>关键字声明在Java文件的开头。<code>import</code>关键字用于引入其他包中的类。<code>package</code>声明应该在<code>import</code>之前。</p>
</li>
<li><p>Java中有四种访问控制符，它们用于限制类、变量、方法和构造方法的访问范围：</p>
<ol>
<li><strong>public：</strong> 公共访问级别，对所有类可见。被声明为 public 的类、变量、方法和构造方法可以被任何其他类访问。</li>
<li><strong>protected：</strong> 受保护访问级别，在同一包内的类和所有子类可见。被声明为 protected 的成员可以在同一包内的其他类中访问，并且也可以被子类访问。</li>
<li><strong>default（不写访问控制符）：</strong> 默认访问级别，仅在同一包内可见。如果不使用任何访问控制符，则默认为包级私有，只能在同一包内的其他类中访问。</li>
<li><strong>private：</strong> 私有访问级别，只有本类内部可见。被声明为 private 的成员只能在定义它们的类内部访问，其他任何类都无法访问。这就是封装，一般我们会设置seter和geter来读取值。</li>
</ol>
<ul>
<li>在Java中，类可以被声明为私有的，但是有些限制：<ol>
<li><p><strong>私有内部类（Private Inner Class）：</strong> 类可以嵌套在另一个类中，并且被声明为私有。这样的类称为私有内部类，只能在包含它的外部类内部访问。</p>
</li>
<li><p><strong>私有顶级类（Private Top-Level Class）：</strong> 如果将类声明为顶级（非内部）类并且私有，那么只能在同一文件内的其他类中访问。这个类无法被其他文件中的类所访问。</p>
</li>
</ol>
</li>
<li>私有类可以在某种程度上提供更严格的访问控制，限制了该类的可见性范围。然而，这种做法在实际开发中很少使用，因为通常情况下，Java类的可访问性要么是公共的（<code>public</code>）、包级私有的（默认，没有修饰符）、受保护的（<code>protected</code>），而不是私有的。 这些访问控制符允许开发人员控制类、方法和变量的可访问性，有助于实现封装和安全性。</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">PrivateInnerClass</span> {</span><br><span class="line">        <span class="comment">// 内部类的内容</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外部类的内容</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PrivateTopLevelClass.java 文件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrivateTopLevelClass</span> {</span><br><span class="line">    <span class="comment">// 类的内容</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnotherClass</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 在同一文件内可以访问 PrivateTopLevelClass 类</span></span><br><span class="line">        <span class="type">PrivateTopLevelClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrivateTopLevelClass</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol start="14">
<li><p><strong>对私有属性如何进行读写控制？Seter和Geter方法的作用？</strong></p>
<ul>
<li>私有属性可以通过公有的setter和getter方法进行读写控制，setter方法用于设置私有属性的值，getter方法用于获取私有属性的值。</li>
</ul>
</li>
<li><p><strong>工厂模式的概念和实现方式？静态成员和方法的含义及访问控制？</strong></p>
<ul>
<li>工厂模式是一种创建对象的设计模式，将对象的创建过程封装在工厂方法中，返回所需对象的实例。</li>
<li>静态成员和方法属于类而不是对象，可以通过类名直接访问。静态成员和方法在内存中只有一份副本，不需要创建对象即可访问。</li>
</ul>
</li>
<li><p><strong>非访问控制符有哪些？</strong></p>
<ul>
<li>static：static 方法和变量属于类而不是特定的实例，可以通过类名直接访问。用于创建类方法和类变量，使得它们可以在不创建类的实例的情况下被访问。</li>
<li>final：用于修饰类、方法和变量。final 类表示该类不能被继承，final 方法表示该方法不能被覆盖，final 变量表示该变量只能被赋值一次。</li>
<li>abstract：用于创建抽象类和抽象方法。abstract 类不能被实例化，只能被继承；abstract 方法没有实现，必须在子类中重写。</li>
<li>synchronized：用于多线程编程，确保在同一时刻只有一个线程可以访问对象的特定部分。synchronized 方法或代码块在被一个线程访问时，其他试图访问它的线程将被阻塞。</li>
<li>volatile：用于保证变量在多线程环境下的可见性，禁止指令重排。volatile 变量的值会被立即更新到主存，而不是缓存在线程的工作内存中。</li>
<li>transient：用于修饰变量，表示该变量不会被序列化。transient 变量在序列化过程中会被忽略。</li>
</ul>
</li>
</ol>
<h3 id="抽象类、接口和枚举"><a href="#抽象类、接口和枚举" class="headerlink" title="抽象类、接口和枚举"></a>抽象类、接口和枚举</h3><ol start="17">
<li><p><strong>抽象类的定义要求和完全抽象类的接口定义方式？一个类只能有一个父类但是可以有多个接口，关键词和成员变量的定义？</strong></p>
<ul>
<li>抽象类使用<code>abstract</code>关键字定义，可以包含抽象方法和具体方法。抽象方法没有方法体，只有声明，而完全抽象类是指全部方法都是抽象方法，没有具体实现。</li>
<li>一个类可以继承一个父类，但可以实现多个接口。接口使用<code>interface</code>关键字定义，包含抽象方法的声明。</li>
<li>在接口中，成员变量默认为<code>public static final</code>，方法默认为<code>public abstract</code>。</li>
</ul>
</li>
<li><p><strong>枚举类型的了解程度和相关知识？</strong> <font color="red">（没考，了解一下）</font></p>
<ul>
<li>枚举是一种特殊的类，限制对象的类型在一个有限的范围内。枚举常用于定义常量集合，列出一组可能的值。Java中的枚举使用<code>enum</code>关键字定义。</li>
</ul>
</li>
</ol>
<h2 id="第五章：Java对象、多态与内部类深度解析"><a href="#第五章：Java对象、多态与内部类深度解析" class="headerlink" title="第五章：Java对象、多态与内部类深度解析"></a>第五章：Java对象、多态与内部类深度解析</h2><h3 id="变量及其传递"><a href="#变量及其传递" class="headerlink" title="变量及其传递"></a>变量及其传递</h3><ol>
<li><p><strong>基本数据类型和引用类型的区别是什么？它们在传递过程中有何异同点？</strong></p>
<ul>
<li>基本数据类型直接存储数据值，而引用类型存储的是对象的引用（地址）。</li>
<li>传递基本数据类型是拷贝实际的值，而传递引用类型是拷贝引用地址。</li>
</ul>
</li>
<li><p><strong>Java中基本数据类型在传递过程中是如何进行拷贝的？引用类型传递的是什么？</strong></p>
<ul>
<li>基本数据类型传递时是传递实际的值（直接拷贝），而引用类型传递时是拷贝对象的引用（地址）。</li>
</ul>
</li>
<li><p><strong>在方法中，为什么成员变量可以使用默认值而方法变量（局部变量）不能？</strong></p>
<ul>
<li>成员变量可以使用默认值是因为它们在对象创建时已经分配了内存并赋予了默认值。方法变量（局部变量）是在方法执行时才创建，没有默认值，必须明确赋值后才能使用。</li>
</ul>
</li>
</ol>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ol start="4">
<li><p><strong>多态的前提条件是什么？哪些条件必须满足才能发生多态？</strong></p>
<ul>
<li>多态的前提条件是存在继承关系，子类覆盖了父类的同名方法，我们称之为虚方法，而且我们一定要有一个子类的对象赋值给了父类的变量，这叫做向上赋形，这时，就会根据各种条件判断应该调用哪个对象。这就叫多态。</li>
</ul>
</li>
<li><p><strong>多态的实现原理是什么？子类如何覆盖父类的同名方法？</strong></p>
<ul>
<li>多态通过动态绑定实现，根据实际对象类型确定调用的方法。子类覆盖父类方法要求方法名和参数列表相同，并且使用<code>@Override</code>注解。</li>
<li>可以在类中间定义一些语句块，语句块前面还可以加static。初始化块（包括静态初始化块和非静态初始化块）的执行顺序优先于构造方法。当创建类的实例时，会先执行初始化块，然后才执行构造方法。静态初始化块在类加载时执行，只会执行一次，并在任何对象创建之前执行。非静态初始化块在每次创建对象时执行，且优先于构造方法执行。</li>
</ul>
</li>
</ol>
<h3 id="对象成员变量初始化"><a href="#对象成员变量初始化" class="headerlink" title="对象成员变量初始化"></a>对象成员变量初始化</h3><ol start="6">
<li><strong>除了在构造函数中，对象的成员变量还能在哪些地方进行初始化？语句块和构造方法的执行顺序是怎样的？</strong><ul>
<li>对象的成员变量可以在构造方法中初始化，同时也可以在实例化代码块中进行初始化。语句块在构造方法之前执行。</li>
</ul>
</li>
</ol>
<h3 id="对象的清除和垃圾回收（没考，了解一下）"><a href="#对象的清除和垃圾回收（没考，了解一下）" class="headerlink" title="对象的清除和垃圾回收（没考，了解一下）"></a>对象的清除和垃圾回收<font color="red">（没考，了解一下）</font></h3><ol start="7">
<li><strong>Java中如何进行对象的清除？是否存在类似析构函数的概念？</strong><ul>
<li>Java自动进行垃圾回收。不存在类似于C++中析构函数的概念，Java的垃圾收集器自动管理对象的销毁。</li>
</ul>
</li>
</ol>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><ol start="8">
<li><p><strong>什么是内部类和匿名类？它与外部类的成员的访问有何特点？</strong><font color="red">（可以看一下）</font></p>
<ul>
<li>内部类是定义在另一个类内部的类。它可以访问外部类的成员，包括私有成员，而外部类则不能直接访问内部类的成员。</li>
<li>匿名类（Anonymous Class）是指在声明类的同时直接创建该类的实例的一种特殊方式。它允许你在需要类的地方（通常是作为参数传递给方法或者实例化对象时），定义一个临时的、一次性的类。匿名类没有名字，一定定义在某个类里面。</li>
</ul>
</li>
<li><p><strong>在内部类中使用static关键字的效果是什么？对外部成员的访问方式有何变化？</strong></p>
<ul>
<li>在内部类中使用<code>static</code>关键字，使得内部类的成员可以直接通过类名访问，不需要实例化外部类。</li>
</ul>
</li>
</ol>
<h3 id="入侵和反制（不涉及，了解一下）"><a href="#入侵和反制（不涉及，了解一下）" class="headerlink" title="入侵和反制（不涉及，了解一下）"></a>入侵和反制<font color="red">（不涉及，了解一下）</font></h3><ol start="10">
<li><strong>入侵和反制相关概念是什么？在Java中如何体现这些概念？</strong><ul>
<li>入侵是指通过某种方式进入系统，而反制则是对入侵进行防范或应对的措施。在Java中，安全性和权限管理是对抗潜在入侵的一种方式。</li>
</ul>
</li>
</ol>
<h2 id="第六章：异常处理与控制流程-Java中的try-catch-finally机制"><a href="#第六章：异常处理与控制流程-Java中的try-catch-finally机制" class="headerlink" title="第六章：异常处理与控制流程 - Java中的try-catch-finally机制"></a>第六章：异常处理与控制流程 - Java中的try-catch-finally机制</h2><h3 id="异常抛出、捕获以及处理机制"><a href="#异常抛出、捕获以及处理机制" class="headerlink" title="异常抛出、捕获以及处理机制"></a>异常抛出、捕获以及处理机制</h3><ol>
<li><p><strong>异常捕获的基本语法和结构是什么？try-catch-finally块如何使用？</strong></p>
<ul>
<li>异常捕获的基本结构是使用<code>try-catch-finally</code>块。在<code>try</code>块中放置可能抛出异常的代码，<code>catch</code>块用于捕获并处理异常，<code>finally</code>块用于清理资源，无论是否有异常都会执行。</li>
</ul>
</li>
<li><p><strong>在try块中抛出异常，catch块如何捕获？如果没有异常会怎样？</strong></p>
<ul>
<li>如果在<code>try</code>块中抛出异常，会匹配对应的<code>catch</code>块。</li>
<li>如果<code>try</code>块中没有抛出异常，程序会继续执行<code>try</code>块后面的代码，并跳过 <code>catch</code> 块的执行。</li>
<li>如果异常抛出了但没有被捕获，即没有对应的 <code>catch</code> 块来处理，异常将沿着调用栈向上抛出，直至被捕获或导致程序终止。可以通过 <code>throws</code> 关键字将异常抛出给调用该方法的地方进行处理，或者使用全局的异常处理器（例如 Thread.setDefaultUncaughtExceptionHandler）捕获未处理的异常。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    <span class="comment">// 可能抛出异常的代码</span></span><br><span class="line">    <span class="comment">// 比如：int result = 10 / 0; // 除零异常</span></span><br><span class="line">} <span class="keyword">catch</span> (ArithmeticException e) {</span><br><span class="line">    <span class="comment">// 捕获特定类型的异常并处理</span></span><br><span class="line">    System.out.println(<span class="string">"除零异常："</span> + e.getMessage());</span><br><span class="line">} <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">    <span class="comment">// 捕获其他类型的异常</span></span><br><span class="line">    System.out.println(<span class="string">"其他异常："</span> + e.getMessage());</span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">    <span class="comment">// finally 块中的代码无论是否发生异常都会执行</span></span><br><span class="line">    <span class="comment">// 一般用于资源释放或清理操作</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol start="3">
<li><p><strong>finally块的作用是什么？无论是否捕获到异常，finally块中的内容会执行吗？</strong></p>
<ul>
<li><code>finally</code>块用于确保无论是否发生异常，里面的代码都会执行。即使在<code>catch</code>块中有<code>return</code>语句，<code>finally</code>块也会在<code>return</code>之前执行。</li>
</ul>
</li>
<li><p><strong>没有声明throw，直接try一个空函数会报错吗？空指针异常会导致什么结果？为什么有些异常报错而有些不会？</strong></p>
<ul>
<li>直接在<code>try</code>块中尝试调用空函数不会报错。空指针异常可能导致程序中止，但不会导致编译错误。有些异常需要显式地处理（捕获或声明抛出），而有些异常则属于运行时异常，不强制要求处理。</li>
</ul>
</li>
<li><p><strong>异常分为可检测和不可检测异常，它们的区别是什么？什么是不可检测异常的例子？</strong></p>
<ul>
<li>可检测异常是指在编译时强制要求处理的异常，需要进行捕获或声明抛出。不可检测异常是指编译器不强制要求处理的异常，通常是运行时异常。例如，<code>NullPointerException</code>是不可检测异常的一种。</li>
</ul>
</li>
</ol>
<h2 id="第七章：工具类和常用算法"><a href="#第七章：工具类和常用算法" class="headerlink" title="第七章：工具类和常用算法"></a>第七章：工具类和常用算法</h2><h3 id="Java中的类和常用方法"><a href="#Java中的类和常用方法" class="headerlink" title="Java中的类和常用方法"></a>Java中的类和常用方法</h3><ol>
<li><p><strong>包的概念和在Java中的作用是什么？碰到了根类意味着什么？</strong></p>
<ul>
<li>包是用于组织和管理Java类的一种机制，可以避免类名冲突，并提供了访问保护机制。根类通常指的是<code>java.lang.Object</code>类，它是所有类的根类。</li>
</ul>
</li>
<li><p><strong>常用方法，如toString方法的作用是什么？</strong></p>
<ul>
<li><code>toString</code>方法用于返回对象的字符串表示。在未重写该方法时，返回的是对象的哈希码。</li>
<li>equals(Object obj): 用于比较两个对象是否相等。</li>
<li>hashCode(): 返回对象的哈希码值。</li>
<li>toString(): 返回对象的字符串表示形式。</li>
<li>getClass(): 返回对象的运行时类。</li>
<li>clone(): 用于创建并返回此对象的副本。</li>
<li>finalize(): 在对象被垃圾回收之前调用。</li>
<li>wait(), notify(), notifyAll(): 用于多线程的同步。</li>
</ul>
</li>
<li><p><strong>八种基本数据类型的包装类有哪些？它们之间是如何进行自动装箱和拆箱的？</strong></p>
<ul>
<li>基本数据类型的包装类包括<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Byte</code>、<code>Short</code>、<code>Character</code>、<code>Boolean</code>。自动装箱是将基本数据类型自动转换为包装类对象，拆箱则相反。</li>
</ul>
</li>
</ol>
<h3 id="Java常用类和相关方法"><a href="#Java常用类和相关方法" class="headerlink" title="Java常用类和相关方法"></a>Java常用类和相关方法</h3><ol start="4">
<li><p><strong>Math类有哪些常用方法？</strong></p>
<ul>
<li><code>Math</code>类包含一系列用于执行基本数学运算的静态方法，如<code>sin()</code>、<code>cos()</code>、<code>sqrt()</code>等。</li>
</ul>
</li>
<li><p><strong>System类有什么作用？它如何进行数组的复制？</strong></p>
<ul>
<li><code>System</code>类提供了访问系统资源和方法的接口。它通过<code>arraycopy()</code>方法进行数组的复制，可以实现数组之间的复制。</li>
</ul>
</li>
<li><p><strong>String类有哪些常见方法？</strong></p>
<ul>
<li><code>String</code>类包含一系列用于字符串操作的方法，如<code>length()</code>、<code>charAt()</code>、<code>substring()</code>等。</li>
</ul>
</li>
<li><p><strong>Date类一般用于哪些操作？</strong></p>
<ul>
<li><code>Date</code>类用于处理日期和时间，包括获取当前日期时间、日期格式化、日期比较等操作。</li>
</ul>
</li>
</ol>
<h3 id="集合类和数据结构"><a href="#集合类和数据结构" class="headerlink" title="集合类和数据结构"></a>集合类和数据结构</h3><ol start="8">
<li><strong>集合类中的Set、List、Map分别代表什么？哪些是键值对结构？</strong><ul>
<li><code>Set</code>代表一组无序且不包含重复元素的集合；<code>List</code>代表有序且可以包含重复元素的集合；<code>Map</code>代表键值对的集合，每个键对应一个值。</li>
<li><code>Map</code>是键值对结构，它以键-值对的方式存储数据，如<code>HashMap</code>、<code>TreeMap</code>等。</li>
</ul>
</li>
</ol>
<p><font color="red">（本章节后面没考，感兴趣的话自己了解）</font></p>
<h2 id="第八章：Java线程的创建和销毁"><a href="#第八章：Java线程的创建和销毁" class="headerlink" title="第八章：Java线程的创建和销毁"></a>第八章：Java线程的创建和销毁</h2><h3 id="线程和调度（没有大题）"><a href="#线程和调度（没有大题）" class="headerlink" title="线程和调度（没有大题）"></a>线程和调度<font color="red">（没有大题）</font></h3><ol>
<li><p><strong>线程的概念是什么？</strong></p>
<ul>
<li>线程是程序执行的单元，是CPU调度的基本单位。它允许程序同时执行多个任务，提高了程序的并发性能。</li>
</ul>
</li>
<li><p><strong>常见的创建线程的方法有哪些？</strong></p>
<ul>
<li>创建线程的方法包括继承<code>Thread</code>类、实现<code>Runnable</code>接口、使用<code>ExecutorService</code>等。</li>
</ul>
</li>
<li><p><strong>线程的状态有哪些？</strong></p>
<ul>
<li>线程的状态包括新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）、等待（Waiting）、计时等待（Timed Waiting）、终止（Terminated）等。</li>
</ul>
</li>
<li><p><strong>线程如何进行调度？调用后会发生什么变化？</strong></p>
<ul>
<li>线程的调度由操作系统的调度器负责，它会根据线程的优先级和状态进行调度。调度后，线程可能从就绪状态转变为运行状态或者被阻塞。</li>
</ul>
</li>
</ol>
<h3 id="流处理"><a href="#流处理" class="headerlink" title="流处理"></a>流处理</h3><ol start="5">
<li><p><strong>数据输入输出是什么？流处理又是怎么回事？</strong></p>
<ul>
<li>数据输入输出是指将数据从某个地方读取出来或写入到某个地方。流处理是一种通过流（Stream）将数据从一个地方传输到另一个地方的方式，它可以是字节流或字符流。</li>
</ul>
</li>
<li><p><strong>流处理中的输入输出流有何区别？字符流和字节流有何异同？</strong></p>
<ul>
<li>输入输出流分为字节流和字符流，字节流适用于处理二进制数据，而字符流则适用于处理文本数据。字符流比字节流多了字符编码的处理，字符流通常使用Reader和Writer，而字节流使用InputStream和OutputStream。</li>
</ul>
</li>
<li><p><strong>节点流和过滤器流是什么？具体指什么内容？</strong></p>
<ul>
<li>节点流是直接连接到数据源或目的地的流，例如<code>FileInputStream</code>和<code>FileOutputStream</code>。过滤器流是基于节点流构建的，可以对数据进行加工和处理，例如<code>BufferedInputStream</code>和<code>BufferedOutputStream</code>。</li>
</ul>
</li>
</ol>
<h2 id="第九章：Java文件流I-O"><a href="#第九章：Java文件流I-O" class="headerlink" title="第九章：Java文件流I/O"></a>第九章：Java文件流I/O</h2><p>当然，请让我逐一回答您提出的问题。</p>
<h3 id="文件和目录处理（对目录的处理及之后不考）"><a href="#文件和目录处理（对目录的处理及之后不考）" class="headerlink" title="文件和目录处理（对目录的处理及之后不考）"></a>文件和目录处理<font color="red">（对目录的处理及之后不考）</font></h3><ol>
<li><p><strong>在Java中，如何使用File类来处理文件？</strong></p>
<ul>
<li>可以使用<code>File</code>类来创建、删除、重命名、获取文件信息等操作。首先需要创建<code>File</code>对象，然后可以使用其提供的方法来执行相应的操作。</li>
</ul>
</li>
<li><p><strong>File类有哪些常用的方法？</strong></p>
<ul>
<li><code>File</code>类有许多方法用于操作文件，如<code>createNewFile()</code>创建新文件、<code>delete()</code>删除文件、<code>renameTo()</code>重命名文件、<code>exists()</code>检查文件是否存在等。</li>
</ul>
</li>
<li><p><strong>File类能做哪些对文件的操作？</strong></p>
<ul>
<li><code>File</code>类可以进行多种文件操作，包括获取文件名、路径、大小、修改日期等文件信息的获取，以及创建、删除、重命名文件等文件操作。</li>
</ul>
</li>
</ol>
<h2 id="第十章：Java面向GUI编程"><a href="#第十章：Java面向GUI编程" class="headerlink" title="第十章：Java面向GUI编程"></a>第十章：Java面向GUI编程</h2><h3 id="GUI中的组件、容器和监听器"><a href="#GUI中的组件、容器和监听器" class="headerlink" title="GUI中的组件、容器和监听器"></a>GUI中的组件、容器和监听器</h3><ol>
<li><p><strong>GUI中常见的组件有哪些？</strong></p>
<ul>
<li>在GUI中，常见的组件包括：文本框（TextField）、标签（Label）、按钮（Button）、复选框（Checkbox）、单选按钮（RadioButton）、下拉列表框（ComboBox）、列表（List）、滑动条（Slider）、菜单（Menu）和菜单项（MenuItem）等。</li>
</ul>
</li>
<li><p><strong>容器是什么？GUI中有哪些常见的容器？</strong></p>
<ul>
<li>容器是一种能够容纳其他组件的组件。在GUI中，常见的容器包括窗口（Window）、面板（Panel）、框架（Frame）等。</li>
</ul>
</li>
<li><p><strong>GUI中有哪些常见的监听器？对于常见组件，常见的监听器需要实现什么方法？</strong></p>
<ul>
<li>常见的监听器包括：ActionListener、ItemListener、MouseListener、KeyListener、WindowListener等。对于常见组件，常见的监听器需要实现对应接口中的方法，例如<code>ActionListener</code>需要实现<code>actionPerformed</code>方法。</li>
</ul>
</li>
<li><p><strong>布局管理器有哪些？</strong></p>
<ul>
<li>布局管理器是用于在GUI界面中定位和控制组件位置的工具。常见的布局管理器包括：<ul>
<li>BorderLayout：将组件放置在东、西、南、北、中五个区域。</li>
<li>FlowLayout：从左到右依次排列组件，自动换行。</li>
<li>GridLayout：将组件放置在网格中，行列固定。</li>
<li>GridBagLayout：更灵活的网格布局，可定制性高。</li>
<li>CardLayout：管理多个组件，只显示一个组件。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>边界、流式和网格布局是什么？</strong></p>
<ul>
<li>边界布局（BorderLayout）将组件放置在东、西、南、北、中五个区域。</li>
<li>流式布局（FlowLayout）按照添加顺序从左到右排列组件，自动换行。</li>
<li>网格布局（GridLayout）将组件放置在规则的行列网格中。</li>
</ul>
</li>
<li><p><strong>Panel（面板）的默认布局是什么？</strong></p>
<ul>
<li><code>Panel</code>的默认布局是<code>FlowLayout</code>。</li>
</ul>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.liushen.fun/">Willow-God</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.liushen.fun/posts/f7016786/">https://blog.liushen.fun/posts/f7016786/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.liushen.fun" target="_blank">LiuShen's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">期末复习</a></div><div class="post-share"><div class="social-share" data-image="https://wallpapercave.com/wp/wp7250277.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="/pluginsSrc/butterfly-extsrc/sharejs/dist/css/share.min.css?v=1.1.3" media="print" onload="this.media='all'"><script src="/pluginsSrc/butterfly-extsrc/sharejs/dist/js/social-share.min.js?v=1.1.3" defer=""></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>来😍鼠标过来一点~</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/config/img/wechat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/config/img/wechat.png" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/config/img/wechat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/config/img/wechat.png" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="prev-post pull-left" href="/posts/d606be0f/" title="使用BiLSTM神经网络+PyTorch实现汉语分词模型的训练"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.qyliu.top/i/2024/03/22/65fc5cc97776f.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">使用BiLSTM神经网络+PyTorch实现汉语分词模型的训练</div></div></a><a class="next-post pull-right" href="/posts/a74e83a1/" title="操作系统课程主要知识点"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://and-pc.com/wp-content/uploads/2020/07/image-1024x560-1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">操作系统课程主要知识点</div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a href="/posts/3ecd60/" title="Java实现多端图书管理系统"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wallpapercave.com/wp/wp7250277.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-05</div><div class="title">Java实现多端图书管理系统</div></div></a><a href="/posts/a74e83a1/" title="操作系统课程主要知识点"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://and-pc.com/wp-content/uploads/2020/07/image-1024x560-1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-04</div><div class="title">操作系统课程主要知识点</div></div></a><a href="/posts/f2c15334/" title="计算机网络考研复习：概述"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.qyliu.top/i/2024/05/22/664dfc89133c2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-23</div><div class="title">计算机网络考研复习：概述</div></div></a></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.qyliu.top/i/2024/03/21/65fc570ca9fe7.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info-name">Willow-God</div><div class="author-info-description">清羽 〄 飞扬</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">52</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">69</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/willow-god"><i class="fab fa-github"></i><span>Follow Me 🛫</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:01@liushen.fun" target="_blank" title="Email"><i class="fa-solid fa-envelope"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=2411457922&amp;site=qq&amp;menu=yes" target="_blank" title="QQ：2411457922"><i class="fa-brands fa-qq"></i></a><a class="social-icon" href="https://wakatime.com/@LiuShen" target="_blank" title="Wakatime"><i class="fa-solid fa-chart-column"></i></a><a class="social-icon" href="https://blog.liushen.fun/atom.xml" target="_blank" title="rss地址"><i class="fa-solid fa-rss"></i></a></div></div><div class="card-widget" id="card-poem"><div id="poem_sentence"></div><div id="poem_info"><div id="poem_dynasty"></div><div id="poem_author"></div></div></div><script src="/js/jinrishici.js" charset="utf-8"></script><script type="text/javascript">jinrishici.load(function(result) {
var sentence = document.querySelector("#poem_sentence")
var author = document.querySelector("#poem_author")
var dynasty = document.querySelector("#poem_dynasty")

var sentenceText = result.data.content
sentenceText = sentenceText.substr(0, sentenceText.length - 1);
sentence.innerHTML = sentenceText
dynasty.innerHTML = result.data.origin.dynasty
author.innerHTML = result.data.origin.author + '《' + result.data.origin.title + '》'
});</script><div class="card-widget card-announcement"><div class="item-headline"><i class="fa fa-user"></i><span>欢迎来访者</span></div><div id="welcome-info"></div><script src="/js/txmap.js"></script><script data-pjax="data-pjax">var longitude="108.546767";
var Latitude="34.579480";
var txkey="44BBZ-IZPLZ-V6PXP-ZYLRT-JKFH3-DOFJ6";
var ipLoacation;
window.onload = () => {welcometxmap()};
document.addEventListener("pjax:complete", welcometxmap());</script></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><p><strong>博客架构概览：</strong><br>⚙️框架核心：Hexo<br>🕹️界面设计：Butterfly<br>🔮安全保障：长亭雷池<br>🔩管理工具：宝塔面板，1Panel<br>🎰服务器支持：阿里云，腾讯云<br>🎲CDN加速：多吉云，无畏云<br><strong>快捷跳转地址：</strong><br>👻博客主站：<a href="https://blog.liushen.fun">blog.liushen.fun</a><br>😶‍🌫️博客分栏：<a target="_blank" rel="noopener" href="https://www.qingyang.eu.org">qingyang.eu.org</a><br>🤖个人导航：<a target="_blank" rel="noopener" href="https://www.liushen.fun">www.liushen.fun</a><br></p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/config/img/notice.gif" alt="可爱捏" title="可爱捏" style="width:100%; border-radius:10px;"></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%80%83%E8%AF%95%E5%88%86%E6%95%B0%E5%8D%A0%E6%AF%94"><span class="toc-text">考试分数占比</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%80%83%E8%AF%95%E9%87%8D%E7%82%B9%E5%BD%92%E7%BA%B3%E6%80%BB%E7%BB%93"><span class="toc-text">考试重点归纳总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9AJAVA%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86%EF%BC%88%E5%8D%95%E9%80%89%E9%A2%98%EF%BC%8C%E5%88%A4%E6%96%AD%E9%A2%98%EF%BC%8C%E5%A4%A7%E9%A2%98%E4%B8%8D%E9%9A%BE%EF%BC%89"><span class="toc-text">第一章：JAVA语言基础背景知识（单选题，判断题，大题不难）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9Ahello-world%EF%BC%8C%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F"><span class="toc-text">第二章：hello world，第一个Java程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9AJava%E5%9F%BA%E7%A1%80%E6%A6%82%E8%A7%88%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%E4%B8%8E%E6%95%B0%E7%BB%84%EF%BC%88%E9%87%8D%E7%82%B9%E5%86%85%E5%AE%B9%EF%BC%89"><span class="toc-text">第三章：Java基础概览：数据类型、运算符、程序结构与数组（重点内容）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">引用类型和类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F%EF%BC%8C%E6%B3%A8%E9%87%8A"><span class="toc-text">定义变量和常量，注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E3%80%81%E4%BD%8D%E8%BF%90%E7%AE%97%E5%92%8C%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">逻辑、位运算和优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="toc-text">赋值运算符和程序结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%92%8C%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-text">循环和控制语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-text">数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9AJava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%8E%A2%E7%B4%A2"><span class="toc-text">第四章：Java面向对象编程基础探索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89"><span class="toc-text">类中的成员变量和方法定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%92%8C%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-text">构造方法和类的继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E3%80%81%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%AC%A6%E3%80%81static"><span class="toc-text">包、访问控制符、static</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%81%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%9E%9A%E4%B8%BE"><span class="toc-text">抽象类、接口和枚举</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9AJava%E5%AF%B9%E8%B1%A1%E3%80%81%E5%A4%9A%E6%80%81%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90"><span class="toc-text">第五章：Java对象、多态与内部类深度解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E4%BC%A0%E9%80%92"><span class="toc-text">变量及其传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-text">多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">对象成员变量初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B8%85%E9%99%A4%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%88%E6%B2%A1%E8%80%83%EF%BC%8C%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B%EF%BC%89"><span class="toc-text">对象的清除和垃圾回收（没考，了解一下）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A5%E4%BE%B5%E5%92%8C%E5%8F%8D%E5%88%B6%EF%BC%88%E4%B8%8D%E6%B6%89%E5%8F%8A%EF%BC%8C%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B%EF%BC%89"><span class="toc-text">入侵和反制（不涉及，了解一下）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%8E%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B-Java%E4%B8%AD%E7%9A%84try-catch-finally%E6%9C%BA%E5%88%B6"><span class="toc-text">第六章：异常处理与控制流程 - Java中的try-catch-finally机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%8A%9B%E5%87%BA%E3%80%81%E6%8D%95%E8%8E%B7%E4%BB%A5%E5%8F%8A%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-text">异常抛出、捕获以及处理机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%92%8C%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95"><span class="toc-text">第七章：工具类和常用算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%92%8C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">Java中的类和常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%92%8C%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95"><span class="toc-text">Java常用类和相关方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%B1%BB%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">集合类和数据结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81"><span class="toc-text">第八章：Java线程的创建和销毁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%B0%83%E5%BA%A6%EF%BC%88%E6%B2%A1%E6%9C%89%E5%A4%A7%E9%A2%98%EF%BC%89"><span class="toc-text">线程和调度（没有大题）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E5%A4%84%E7%90%86"><span class="toc-text">流处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0%EF%BC%9AJava%E6%96%87%E4%BB%B6%E6%B5%81I-O"><span class="toc-text">第九章：Java文件流I/O</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E5%A4%84%E7%90%86%EF%BC%88%E5%AF%B9%E7%9B%AE%E5%BD%95%E7%9A%84%E5%A4%84%E7%90%86%E5%8F%8A%E4%B9%8B%E5%90%8E%E4%B8%8D%E8%80%83%EF%BC%89"><span class="toc-text">文件和目录处理（对目录的处理及之后不考）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0%EF%BC%9AJava%E9%9D%A2%E5%90%91GUI%E7%BC%96%E7%A8%8B"><span class="toc-text">第十章：Java面向GUI编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GUI%E4%B8%AD%E7%9A%84%E7%BB%84%E4%BB%B6%E3%80%81%E5%AE%B9%E5%99%A8%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-text">GUI中的组件、容器和监听器</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/4dc716ec/" title="Friend-Circle-Lite:轻量友链朋友圈"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.qyliu.top/i/2024/07/19/6699436fe02ec.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Friend-Circle-Lite:轻量友链朋友圈"></a><div class="content"><a class="title" href="/posts/4dc716ec/" title="Friend-Circle-Lite:轻量友链朋友圈">Friend-Circle-Lite:轻量友链朋友圈</a><time datetime="2024-08-11T16:02:00.000Z" title="更新于 2024-08-12 00:02:00">2024-08-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/a64defb4/" title="魔改笔记七：分类条及外链卡片"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.qyliu.top/i/2024/08/10/66b74df1ab511.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="魔改笔记七：分类条及外链卡片"></a><div class="content"><a class="title" href="/posts/a64defb4/" title="魔改笔记七：分类条及外链卡片">魔改笔记七：分类条及外链卡片</a><time datetime="2024-08-09T17:40:00.000Z" title="更新于 2024-08-10 01:40:00">2024-08-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/159f1aa5/" title="域名迁移至 blog.liushen.fun"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.qyliu.top/i/2024/08/10/66b6479e1d33c.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="域名迁移至 blog.liushen.fun"></a><div class="content"><a class="title" href="/posts/159f1aa5/" title="域名迁移至 blog.liushen.fun">域名迁移至 blog.liushen.fun</a><time datetime="2024-08-09T08:00:00.000Z" title="更新于 2024-08-09 16:00:00">2024-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/3850e950/" title="CloudFlare实用项目推荐"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.qyliu.top/i/2024/07/31/66a922cb9adcc.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CloudFlare实用项目推荐"></a><div class="content"><a class="title" href="/posts/3850e950/" title="CloudFlare实用项目推荐">CloudFlare实用项目推荐</a><time datetime="2024-07-31T17:32:00.000Z" title="更新于 2024-08-01 01:32:00">2024-08-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap" style="background: transparent"><div id="footer_icons"><div><a class="icon_link" rel="noopener external nofollow" href="https://www.qyliu.top/" title="导航站点" target="_blank"><i class="fa-solid fa-compass"></i></a><a class="icon_link" rel="noopener external nofollow" href="https://admin.qidian.qq.com/static_proxy/b2b-qq/wpa-link/index.html#/person?uin=2411457922" title="联系QQ" target="_blank"><i class="fa-brands fa-qq"></i></a><a class="icon_link" rel="noopener external nofollow" href="https://github.com/willow-god" title="我的github主页" target="_blank"><i class="fa-brands fa-github"></i></a><a class="icon_link" rel="noopener external nofollow" href="mailto:01@liushen.fun" title="发送邮件至博主邮箱" target="_blank"><i class="fa-solid fa-envelope"></i></a></div><img class="footer_logo" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.qyliu.top/i/2024/05/12/663f9fc48820a.png" onclick="btf.scrollToDest(0,500)" title="返回顶部"><div><a class="icon_link" rel="noopener external nofollow" href="https://wakatime.com/@LiuShen" title="Wikitime" target="_blank"><i class="fa-solid fa-clock"></i></a><a class="icon_link" rel="noopener external nofollow" href="https://gitlab.com/" title="gitlab" target="_blank"><i class="fa-brands fa-gitlab"></i></a><a class="icon_link" href="/shuoshuo/" title="日常说说" data-pjax-state="data-pjax-state"><i class="fa-solid fa-file-pen"></i></a><a class="icon_link" href="/comment/" title="留言板" data-pjax-state="data-pjax-state"><i class="fa-solid fa-comment"></i></a></div></div><div id="footer_content"><div class="footer-group"><h3 class="footer-title">关于本站</h3><div class="footer-links"><a class="footer-item" target="_blank" href="https://www.qyliu.top/">导航站点</a><a class="footer-item" href="/shuoshuo/">日常说说</a><a class="footer-item" target="_blank" href="https://um.liushen.fun/share/G8C2aR0IszHE5VBl/blog.liushen.fun">访客信息</a><a class="footer-item" target="_blank" href="https://m.liushen.fun/">盐焗星球</a><a class="footer-item" target="_blank" href="https://listen.qyliu.top/">在线状态</a><a class="footer-item" href="/subscribe/">订阅本站</a></div></div><div class="footer-group"><h3 class="footer-title">加入组织</h3><div class="footer-links"><a class="footer-item" target="_blank" href="https://www.boyouquan.com/home">博友圈</a><a class="footer-item" target="_blank" href="https://boke.lu/">博客录</a><a class="footer-item" target="_blank" href="https://blogwe.com/">博客我们</a><a class="footer-item" target="_blank" href="https://firewood.news/">积薪站点</a><a class="footer-item" target="_blank" href="https://bf.zzxworld.com/">发现博客</a><a class="footer-item" target="_blank" href="https://ourblo.gs/">OurBlogs</a></div></div><div class="footer-group"><h3 class="footer-title">文章整理</h3><div class="footer-links"><a class="footer-item" href="/categories/博客管理/">博客管理</a><a class="footer-item" href="/categories/学习资料/">学习资料</a><a class="footer-item" href="/categories/日常分享/">日常分享</a><a class="footer-item" href="/achieve/">时光卷轴</a><a class="footer-item" href="/charts/">文章通览</a><a class="footer-item" href="/categories/">查看全部</a></div></div><div class="footer-group"><h3 class="footer-title">文章标签</h3><div class="footer-links"><a class="footer-item" href="/tags/JavaScript/">JS知识</a><a class="footer-item" href="/tags/Hexo/">本站框架</a><a class="footer-item" href="/tags/机器学习/">机器学习</a><a class="footer-item" href="/tags/日记/">个人日记</a><a class="footer-item" href="/tags/CSS/">CSS知识</a><a class="footer-item" href="/tags/">查看全部</a></div></div><div class="footer-group"><h3 class="footer-title">自建工具</h3><div class="footer-links"><a class="footer-item" target="_blank" rel="noopener" href="https://docs_s.tianli0.top/">必应AI</a><a class="footer-item" target="_blank" rel="noopener" href="https://chat.qyliu.top/">NextGPT</a><a class="footer-item" target="_blank" rel="noopener" href="https://draw.qyliu.top/">随心画板</a><a class="footer-item" target="_blank" rel="noopener" href="https://mindmap.qyliu.top/">思维导图</a><a class="footer-item" target="_blank" rel="noopener" href="https://ittools.qyliu.top/">IT工具箱</a><a class="footer-item" target="_blank" rel="noopener" href="https://calcium.qyliu.top/">在线计算</a></div></div><div class="footer-group" id="friend-links-in-footer"><h3 class="footer-title">友链<button title="换一批" href="javascript:;" onclick="liushen.randomLink()"><i class="fa-solid fa-rotate-right"></i></button></h3><div class="footer-links"><a class="footer-item" target="_blank" href="https://blog.liushen.fun">测试1</a><a class="footer-item" target="_blank" href="https://blog.liushen.fun">测试2</a><a class="footer-item" target="_blank" href="https://blog.liushen.fun">测试3</a><a class="footer-item" target="_blank" href="https://blog.liushen.fun">测试4</a><a class="footer-item" target="_blank" href="https://blog.liushen.fun">测试5</a><a class="footer-item" href="/link/" data-pjax-state="data-pjax-state">查看更多</a></div></div></div><div id="footer-bottom"><div class="footer-bottom-content"><div class="footer-bottom-left"><span class="copyright">©2021 - 2024 By <a target="_blank" rel="noopener" href="https://blog.liushen.fun/about/" title="点击访问&quot;LiuShen&quot;的主页" style="margin-left:5px">LiuShen</a></span><div><a class="footer-bottom-link" target="_blank" href="https://beian.miit.gov.cn/" rel="noopener external nofollow" title="工信部备案号">陕ICP备2024028531号</a><a class="footer-bottom-link" target="_blank" href="https://beian.mps.gov.cn/#/query/webSearch?code=61011602000637" rel="noopener external nofollow" title="公安备案号">陕公网安备61011602000637号</a></div></div><div class="footer-bottom-right"> <div id="runtime" title="本站运行时间">本站已苟活：0 天 0 时 0 分 0 秒</div><div> <a class="footer-bottom-link" target="_blank" href="https://www.dogecloud.com/" rel="noopener external nofollow" title="本站通过多吉云CDN提供站点加速">多吉云CDN</a><a class="footer-bottom-link" target="_blank" href="https://hexo.io/zh-cn/" rel="noopener external nofollow" title="本站使用Hexo架构搭建而成">Hexo静态框架</a><a class="footer-bottom-link" target="_blank" href="https://butterfly.js.org/" rel="noopener external nofollow" title="本站由Butterfly主题魔改而成">Butterfly主题</a></div></div></div></div></div><script>if (!window.liushen) {
  window.liushen = {
    saveData: (key, data) => {
      localStorage.setItem(key, JSON.stringify({
        time: Date.now(),
        data: data
      }));
    },

    loadData: (key, validTimeInMinutes) => {
      let storedData = JSON.parse(localStorage.getItem(key));
      if (storedData) {
        let elapsedTime = Date.now() - storedData.time;
        if (elapsedTime >= 0 && elapsedTime < validTimeInMinutes * 60000) {
          return storedData.data;
        }
      }
      return null;
    },

    runtime: () => {
      const formatTime = (unit) => unit > 9 ? unit : "0" + unit;
      const startTime = new Date('2021/12/12 01:27:36').getTime();
      const currentTime = Date.now();
      let elapsedTimeInSeconds = Math.round((currentTime - startTime) / 1000);

      let runtimeText = "本站已苟活：";
      if (elapsedTimeInSeconds >= 86400) {
        runtimeText += `${formatTime(Math.floor(elapsedTimeInSeconds / 86400))} 天 `;
        elapsedTimeInSeconds %= 86400;
      }
      if (elapsedTimeInSeconds >= 3600) {
        runtimeText += `${formatTime(Math.floor(elapsedTimeInSeconds / 3600))} 时 `;
        elapsedTimeInSeconds %= 3600;
      }
      if (elapsedTimeInSeconds >= 60) {
        runtimeText += `${formatTime(Math.floor(elapsedTimeInSeconds / 60))} 分 `;
        elapsedTimeInSeconds %= 60;
      }
      runtimeText += `${formatTime(elapsedTimeInSeconds)} 秒`;

      const runtimeElement = document.getElementById("runtime");
      if (runtimeElement) {
        runtimeElement.innerHTML = runtimeText;
      }
      setTimeout(window.liushen.runtime, 1000);
    },

    randomLink: () => {
      let linksData = window.liushen.loadData("links", 30);
      if (linksData) {
        let linkElements = document.querySelectorAll("#friend-links-in-footer .footer-item");
        if (!linkElements.length) return;

        for (let i = 0; i < linkElements.length; i++) {
          let randomIndex = Math.floor(Math.random() * linksData.length);
          linkElements[i].innerText = linksData[randomIndex].name;
          linkElements[i].href = linksData[randomIndex].link;
          linksData.splice(randomIndex, 1);
        }
      } else {
        fetch("/flink_count.json")
          .then(response => response.json())
          .then(data => {
            window.liushen.saveData("links", data.link_list);
            window.liushen.randomLink();
          });
      }
    }
  };
}

if (true) {
  window.liushen.randomLink();
  document.addEventListener("DOMContentLoaded", window.liushen.randomLink);
  window.liushen.runtime();
} else {
  window.liushen.randomLink();
  window.liushen.runtime();
}</script></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="cat" onclick="toggleLive2dVisibility()" title="小猫显隐"><i class="fa-solid fa-cat"></i></button><button id="fullscreen" onclick="toggleFullScreen()" title="全屏切换"><i class="fa-solid fa-expand"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="fa-solid fa-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="fa-solid fa-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="fa-solid fa-arrow-rotate-right"></i></div><div class="rightMenu-item" id="menu-home"><i class="fa-solid fa-house"></i></div></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" id="copy" href="javascript:rm.copySelect();"><i class="fa-solid fa-copy"></i><span>复制选中文字</span></a><a class="rightMenu-item" id="reply" href="javascript:rm.replySelect();"><i class="fa-regular fa-comment"></i><span>评论选中段落</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" href="/archives/"><i class="fa-solid fa-archive"></i><span>文章时间线</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="fa-solid fa-folder-open"></i><span>文章分大类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="fa-solid fa-tags"></i><span>文章小标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuNormal"><a class="rightMenu-item menu-link" id="menu-radompage" href="/comment/"><i class="fa-solid fa-shoe-prints"></i><span>随心留言板</span></a><div class="rightMenu-item" id="menu-translate"><i class="fa-solid fa-earth-asia"></i><span>繁简模式切换</span></div><div class="rightMenu-item" id="menu-darkmode"><i class="fa-solid fa-moon"></i><span>切换亮暗模式</span></div><div class="rightMenu-item" id="menu-live2dvisibility"><i class="fa-solid fa-cat"></i><span>小猫显示隐藏</span></div><div class="rightMenu-item" id="menu-print"><i class="fa-solid fa-print fa-fw"></i><span>打印整个页面</span></div><a class="rightMenu-item menu-link" id="statement" href="/statement/"><i class="fa-regular fa-copyright fa-fw"></i><span>网站声明</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js?v=5.0.0"></script><script src="/js/main.js?v=5.0.0"></script><script src="/js/jquery-3.7.1.slim.min.js?v=5.0.0"></script><script src="/js/others.js?v=5.0.0"></script><script src="/js/echarts.min.js?v=5.0.0"></script><script src="/js/rightmenu.js?v=5.0.0"></script><script src="/js/tw_cn.js?v=5.0.0"></script><script src="/pluginsSrc/@fancyapps/ui/dist/fancybox/fancybox.umd.js?v=5.0.36"></script><script src="/pluginsSrc/instant.page/instantpage.js?v=5.2.0" type="module"></script><script src="/pluginsSrc/vanilla-lazyload/dist/lazyload.iife.min.js?v=19.1.3"></script><div class="js-pjax"><script>(() => {
  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.qyliu.top',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.qyliu.top',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))

    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(init,0)
    else btf.getScript('/pluginsSrc/twikoo/dist/twikoo.all.min.js?v=1.6.38').then(init)
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[aside.card_aside.card_aside.card_newest_comments.code]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://twikoo.qyliu.top',
        region: '',
        pageSize: 5,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        btf.saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      btf.getScript('/pluginsSrc/twikoo/dist/twikoo.all.min.js?v=1.6.38').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = btf.saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  btf.addGlobalFn('pjaxComplete', newestCommentInit, 'twikoo_newestComment')
})</script><script src="/config/memos/memos.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="/pluginsSrc/butterfly-extsrc/dist/fireworks.min.js?v=1.1.3"></script><script src="/pluginsSrc/pjax/pjax.min.js?v=0.2.8"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

const triggerPjaxFn = (val) => {
  if (!val) return
  Object.values(val).forEach(fn => { fn() })
}

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjaxSendOnce')
  btf.removeGlobalFnEvent('themeChange')

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  triggerPjaxFn(window.globalFn.pjaxSend)
})

document.addEventListener('pjax:complete', () => {
  btf.removeGlobalFnEvent('pjaxCompleteOnce')
  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  triggerPjaxFn(window.globalFn.pjaxComplete)
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="/pluginsSrc/algoliasearch/dist/algoliasearch-lite.umd.js?v=4.24.0"></script><script src="/pluginsSrc/instantsearch.js/dist/instantsearch.production.min.js?v=4.73.3"></script><script src="/js/search/algolia.js?v=5.0.0"></script></div></div><!-- hexo injector body_end start --><script data-pjax="">
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/a64defb4/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.qyliu.top/i/2024/08/10/66b74df1ab511.webp" alt="" onerror="this.src=/img/error-page.png; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-10</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/a64defb4/&quot;);" href="javascript:void(0);" alt="">魔改笔记七：分类条及外链卡片</a><div class="blog-slider__text">虽然说域名换了几乎等于从头开始，但是仍然浇不灭我对于网站的热情，该进行的还是得进行。很久都没有总结魔改了，这篇文章就将最近魔改最大的几个部分进行记录，同时对有需要的朋友提供帮助。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/a64defb4/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/159f1aa5/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.qyliu.top/i/2024/08/10/66b6479e1d33c.webp" alt="" onerror="this.src=/img/error-page.png; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/159f1aa5/&quot;);" href="javascript:void(0);" alt="">域名迁移至 blog.liushen.fun</a><div class="blog-slider__text">近期遇见了一个很烦人的事情，bing的所有搜索结果全部消失，我也不知道是怎么回事，已经在联系bing管理员了，不过，其实我很早之前就像换域名了，今天趁此机会，干脆直接换了得了！原有的域名301至新域名，不会影响任何使用。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/159f1aa5/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/3850e950/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.qyliu.top/i/2024/07/31/66a922cb9adcc.webp" alt="" onerror="this.src=/img/error-page.png; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-01</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/3850e950/&quot;);" href="javascript:void(0);" alt="">CloudFlare实用项目推荐</a><div class="blog-slider__text">之前我向大家推荐过vercel上的一些项目，都非常的有趣实用，最近，在和朋友安小歪的聊天中，发现了一些很好玩的cloud flare项目，比如临时邮箱，临时文件传送，计数统计，等等，很多项目都非常好玩，于是在此推荐给大家。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/3850e950/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/4dc716ec/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.qyliu.top/i/2024/07/19/6699436fe02ec.webp" alt="" onerror="this.src=/img/error-page.png; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-21</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/4dc716ec/&quot;);" href="javascript:void(0);" alt="">Friend-Circle-Lite:轻量友链朋友圈</a><div class="blog-slider__text">前两天出现了友链朋友圈因为版本原因导致无法运行的问题，虽然我已经改好了，但是由于bundle文件过大，经常导致加载较慢，于是我自己手搓了一个轻量化友链朋友圈，同时支持通过提交issue实现邮箱订阅本站最新文章，也算是友链朋友圈部署新思路啦，适合喜欢轻量和免费快速的朋友尝试！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/4dc716ec/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/67189760/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.qyliu.top/i/2024/07/06/6688d4b63b50f.webp" alt="" onerror="this.src=/img/error-page.png; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-06</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/67189760/&quot;);" href="javascript:void(0);" alt="">Spikformer脉冲神经网络学习</a><div class="blog-slider__text">近期我们进行了人工智能实训，我们小组选择的是脉冲神经网络，不同于原先的神经网络，这个网络采用的是脉冲信号，目前脉冲神经网络的效果并不是很好，但是因为是一个全新的神经网络架构，并且基于生物启发的计算方式，使得它们在处理稀疏和非结构化数据时具有独特的优势。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/67189760/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer="" src="/config/swiper/swiper.min.js"></script><script defer="" data-pjax="" src="/config/swiper/swiper_init.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"superSample":2,"width":250,"height":500,"position":"left","hOffset":0,"vOffset":-140},"mobile":{"show":false,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>